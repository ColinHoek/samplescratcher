<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <title>Sample Scratcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e0e;
      --panel: #1e211f5c;
      --panel-elev: #222523;
      --line: #2a2a2a;
      --text: #f1f1f1;
      --muted: #a7a7a7;
      --muted-2: #8b8b8b;
      --accent: #1a9d4a;
      --accent-hover: #22c55e;
      --green: #22c55e;
      --danger: #ef4444;
      --white: #ffffff;
      --shadow: 0 10px 30px rgba(0, 0, 0, .3);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overscroll-behavior: none;
      touch-action: manipulation;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(to bottom, #181C1A 0%, #0D0D0D 100%);
      background-attachment: fixed;
      background-repeat: no-repeat;
      background-size: 100% 100%;
    }

    header {
      padding: 18px 22px;
      border-bottom: 1px solid var(--line);
      background: #0b0b0b;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: .5px;
      font-family: Oswald, sans-serif;
      font-weight: 700;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding-right: 20px;
      padding-bottom: 20px;
      padding-left: 20px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      overflow: hidden;
      z-index: 2
    }

    .panel.elev {
      background: var(--panel-elev);
      box-shadow: var(--shadow);
      border-color: #222523;
      z-index: 3
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title .left-group {
      display: flex;
      align-items: center;
      gap: 8px;
      /* spacing between name, pill, and reload */
    }

    .section-title h2 {
      margin: 10px;
      font-size: 22px;
      font-family: Oswald, sans-serif;
      font-weight: 600;
      letter-spacing: .3px;
    }

    .section-sub {
      margin: -6px 0 8px;
      color: var(--muted-2);
      font-size: 14px;
    }

    .dropzone {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 260px;
      border: 2px dashed var(--line);
      border-radius: 18px;
      background: #121212;
      cursor: pointer;
      transition: transform .18s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }

    .dropzone:hover {
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, .25);
    }

    .dropzone.hover {
      border-color: var(--accent);
      background: #0f1511;
    }

    .dz-inner {
      text-align: center;
      line-height: 1.6;
    }

    .big-plus {
      font-size: 60px;
      font-weight: 700;
      font-family: Oswald, sans-serif;
      display: block;
    }

    .dz-title {
      font-size: 18px;
      font-weight: 600;
    }

    .dz-browse {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: underline;
    }

    .dz-browse:hover {
      color: var(--accent-hover);
    }

    input[type="file"] {
      display: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button,
    input,
    select {
      font-size: 16px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #101010;
      color: var(--text);
      transition: transform .12s ease, background .18s ease, box-shadow .18s ease, border-color .18s ease;
    }

    button {
      cursor: pointer;
    }

    .no-hover:hover {
      transform: translateY(0px);
    }

    button:hover {
      transform: translateY(-1px);
    }

    .primary {
      background: var(--accent);
      color: #000;
      border-color: transparent;
    }

    .primary:hover {
      background: var(--accent-hover);
    }

    .ghost {
      background: #141414;
    }

    .round-icon {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      border: 1px solid var(--line);
      background: linear-gradient(#121212, #0e0e0e);
      margin: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .25), inset 0 1px 0 rgba(255, 255, 255, .05);
    }

    .round-icon:active {
      transform: scale(.96);
    }

    .record-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 6px rgba(239, 68, 68, .12);
    }

    .stop-square {
      width: 18px;
      height: 18px;
      background: var(--white);
      box-shadow: 0 0 0 6px rgba(255, 255, 255, .1);
    }

    .rec-controls-wrap {
      display: grid;
      place-items: center;
      padding: 10px 0 2px;
    }

    .rec-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      background: #101010;
      border: 1px solid #242424;
      border-radius: 999px;
      padding: 8px 14px;
      box-shadow: var(--shadow);
    }

    .rec-status {
      text-align: center;
      color: var(--muted);
      margin-top: 6px;
      min-height: 18px;
    }

    /* Bubbles overlay website */
    .screen-overlay-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      top: 0;
      left: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 1;
    }

    .bubble {
      position: absolute;
      bottom: -100px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      animation: rise linear forwards;
    }

    @keyframes rise {
      to {
        transform: translateY(-110vh);
        opacity: 0;
      }
    }

    canvas {
      width: 100%;
      background: #121212;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 160px;
      touch-action: auto;
    }

    /* Preselection – smaller, subtle */
    #preCanvas {
      height: 80px;
      background: #121212;
      cursor: crosshair;
    }

    .handles {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .handles .center {
      text-align: center;
      color: var(--muted);
      /* keep label dim */
    }

    .handles .center .value {
      color: #d7d7d7;
      /* pop just the number */
      font-weight: 600;
    }

    .tiny {
      font-size: 13px;
      padding: 6px 10px;
    }

    .pill {
      border-radius: 999px;
      padding: 8px 12px;
    }

    /* Settings controls */
    .settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      column-gap: 20px;
      gap: 14px;
    }

    .field label {
      font-size: 13px;
      color: var(--muted);
      display: inline-block;
    }

    /* Green themed slider */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 280px;
      height: 6px;
      border-radius: 999px;
      background: #2a2a2a;
      outline: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0e0e0e;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
      transition: transform .12s ease, background .18s ease;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent-hover);
      transform: scale(1.06);
    }

    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
    }

    input[type=range]::-moz-range-track {
      background: #2a2a2a;
      height: 6px;
      border-radius: 999px;
    }

    .status {
      min-height: 20px;
      color: var(--muted);
    }

    /* Effects grid */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 14px;
      justify-content: center;
      /* center last card if only one */
    }

    .preset-card {
      background: #2225234A;
      /* semi-transparent initial background */
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      padding: 14px;
      display: grid;
      gap: 14px;
      box-shadow: var(--shadow);
      transition: background 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled {
      background: #222523a1;
      /* solid background after fade-in */
    }

    .preset-card h3 {
      margin: 0;
      font-size: 20px;
      font-family: Oswald, sans-serif;
    }

    .mini-wrap {
      border-radius: 10px;
      overflow: hidden;
      background: #121212;
    }

    .mini-wave {
      width: 100%;
      height: 60px;
      background: #121212;
      display: block;
    }

    .mini-wrap canvas.mini-wave {
      touch-action: auto !important;
    }

    .curve-vis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .curve {
      position: relative;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      background: #121212;
      padding: 8px;
    }

    .curve h4 {
      position: absolute;
      top: 6px;
      left: 10px;
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, .5);
      font-weight: 600;
    }

    .curve canvas {
      width: 100%;
      height: 100px;
      border: none;
      background: transparent;
    }

    .preset-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .preset-actions .primary,
    .preset-actions .btn-ghost {
      width: 100%;
    }

    .preset-card .pname,
    .preset-card .meta b,
    .preset-card .duration {
      display: flex;
      align-items: center;
      opacity: 0.4;
      color: var(--muted);
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .pname,
    .preset-card.enabled .meta b,
    .preset-card.enabled .duration {
      opacity: 1;
      color: #fff;
    }

    .beat-icon {
      display: flex;
      align-items: center;
      pointer-events: none;
    }

    .beat-icon img.beat-svg {
      width: 30px;
      opacity: 0.2;
      transition: opacity 0.6s ease;
    }

    .beat-options {
      position: absolute;
      top: -9999px;
      left: -9999px;
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.2s, transform 0.2s;
    }

    .option-menu,
    .beat-options {
      position: fixed;
      top: -9999px;
      left: -9999px;
      opacity: 0;
      pointer-events: none;
      transform: scale(0.8);
    }

    .option-menu.show,
    .beat-options.show {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1);
      top: auto;
      left: auto;
    }

    .beat-popup {
      display: none;
      position: absolute;
      bottom: 40px;
      left: 0;
      right: 0;
      background: #111;
      border: 1px solid #2a2a2a;
      border-radius: 999px;
      padding: 6px 10px;
      display: flex;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      animation: fadeInUp .25s ease forwards;
      z-index: 5;
    }

    .beat-popup button {
      background: #222;
      border: 1px solid #444;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 13px;
      color: #fff;
      cursor: pointer;
    }

    .beat-popup button:hover {
      background: var(--accent);
      color: #000;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .preset-card.enabled .beat-icon img.beat-svg {
      opacity: 1;
    }

    .preset-card.enabled .beat-icon {
      pointer-events: auto;
    }

    .preset-card .beat-count {
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.5px;
      opacity: 0.4;
      color: #4d4d4d;
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .beat-count {
      opacity: 0.8;
      color: #8b8b8b;
    }

    .preset-card .meta {
      opacity: 0.4;
      color: #4d4d4d;
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .meta {
      opacity: 1;
      color: #8b8b8b;
    }

    .preset-card canvas {
      opacity: 0;
      transition: opacity 0.6s ease;
    }

    .playBtn.playing {
      background: rgb(16, 102, 47);
      /* donkerder groen */
      border-color: transparent;
    }

    .preset-card.enabled canvas {
      opacity: 1;
    }

    .btn-ghost {
      background: #141414;
      border: 1px solid #2a2a2a;
      color: var(--text);
    }

    .meta {
      display: flex;
      align-items: center;
      gap: 5px;
      color: #6f6f6f;
      font-size: 13px;
    }

    .meta b {
      color: #cfcfcf;
      font-weight: 700;
    }

    /* Pulse animatie voor record */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }

      50% {
        box-shadow: 0 0 0 12px rgba(239, 68, 68, .6);
      }

      100% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }
    }

    /* State classes */
    .recording .record-dot {
      background: var(--danger);
      animation: pulse 1.2s infinite;
    }

    .recording .stop-square {
      background: var(--white);
      opacity: 1;
    }

    .idle .stop-square {
      background: var(--white);
      opacity: 0.3;
    }

    .idle .record-dot {
      background: var(--danger);
      animation: none;
    }

    .round-icon.small {
      width: 44px;
      height: 44px;
      margin: 4px;
    }

    /* Icon wrappers centreren */
    .round-icon.small .icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Play driehoekje */
    .icon-play {
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-left: 14px solid var(--white);
    }

    .icon-stop {
      width: 14px;
      height: 14px;
      background: var(--white);
    }

    /* Pause icon */
    .icon-pause {
      display: flex;
      gap: 4px;
    }

    .icon-pause span {
      display: block;
      width: 4px;
      height: 14px;
      background: var(--white);
    }

    .preset-actions button {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    /* Enabled state after generate */
    .preset-actions.enabled button {
      opacity: 1;
      cursor: pointer;
      pointer-events: auto;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }


    /* === Slip Mode Switch === */
    .switch-field {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .switch-label {
      height: 40px;
      font-size: 16px;
      font-family: Oswald, sans-serif;
      letter-spacing: .3px;
    }

    /* Switch styling */
    .switch {
      height: 40px;
      position: relative;
      display: inline-block;
      width: 50px;
      height: 28px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #333;
      transition: .3s;
      border-radius: 999px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      border-radius: 50%;
      transition: .3s;
    }

    /* Active state */
    .switch input:checked+.slider {
      background-color: var(--accent);
    }

    .switch input:checked+.slider:before {
      transform: translateX(22px);
    }

    /* Settings panel (no shadow, flat bottom) */
    #settingsPanel {
      margin-bottom: -15px;
      /* overlap into Effects */
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      box-shadow: none;
      /* remove its own shadow */
      position: relative;
      z-index: 2;
      /* ensure it’s above the page bg */
    }

    /* Effects panel (has shadow, flat top, casts shadow over Settings) */
    #effectsPanel {
      margin-top: 0;
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      box-shadow: var(--shadow);
      /* keep the drop shadow */
      position: relative;
      z-index: 2;
      /* sits above Settings, casts shadow */
    }


    /* Load Panel */
    #loadPanel {
      margin-bottom: -15px;
      /* pull it closer to Pre panel */
      border-bottom-left-radius: 0;
      /* flatten bottom corners */
      border-bottom-right-radius: 0;
      position: relative;
      z-index: 2;
      /* keep it above Pre panel */
    }

    /* Preselection Panel */
    #prePanel {
      margin-top: 0;
      border-top-left-radius: 0;
      /* flatten top corners */
      border-top-right-radius: 0;
    }

    .logo-container {
      text-align: center;
      /* Logo horizontaal centreren */
      padding-top: 30px;
      padding-bottom: 25px;
      /* Boven- en onderruimte, pas aan naar wens */
    }

    .logo-container svg {
      width: 80px;
      /* Startwaarde voor grootte (pas aan) */
      height: auto;
      /* Aspect ratio behouden */
    }

    .ss-logo {
      width: 200px;
    }

    /* --- Option pill --- */
    .option-pill {
      background: transparent;
      color: #a7a7a7;
      border: 1px solid #a7a7a7;
      border-radius: 999px;
      font-size: 0.8rem;
      padding: 4px 10px;
      margin-right: auto;
      cursor: pointer;
      pointer-events: none;
      opacity: 0.4;
      transition: opacity 0.4s ease;
    }

    .option-pill.hidden {
      display: none;
    }

    /* --- Dropdown menu voor de opties --- */
    .option-menu {
      position: absolute;
      display: flex;
      flex-direction: column;
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid #333;
      border-radius: 20px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
      padding: 6px;
      z-index: 9999;
      opacity: 0;
      transform: scale(0.95);
      pointer-events: none;
      transition: opacity 0.2s, transform 0.2s;
    }

    .option-menu.show {
      opacity: 1;
      transform: scale(1);
      pointer-events: auto;
    }

    .option-menu button {
      background: transparent;
      border: 1px solid transparent;
      color: #fff;
      font-size: 0.85rem;
      padding: 6px 12px;
      text-align: left;
      cursor: pointer;
      border-radius: 999px;
      transition: border-color 0.2s, background 0.2s;
    }

    .preset-card.enabled .option-pill {
      color: #ffffff;
      border: 1px solid #ffffff;
      pointer-events: auto;
      opacity: 1;
    }

    .option-menu button:hover {
      border-color: rgba(255, 255, 255, 0.3);
    }

    .option-menu button.selected {
      border-color: #fff;
    }

    .reload-btn {
      background: transparent;
      border: none;
      padding: 0px;
      cursor: pointer;
      opacity: 0.05;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    /* When the preset is enabled */
    .preset-card.enabled .reload-btn {
      opacity: 0.5;
      pointer-events: auto;
    }

    .preset-card.enabled .reload-btn:hover {
      opacity: 1;
    }

    .reload-btn svg {
      width: 18px;
      height: 18px;
      display: block;
      fill: #fff;
    }

    @media (max-width: 600px) {
      .beat-options {
        left: 200px !important;
      }
    }

    @media (max-width: 600px) {
      #generateBtn {
        display: block;
      }
    }

    @media (max-width: 600px) {
      .section-title {
        display: flex;
        align-items: initial;
      }
    }

    @media (max-width: 600px) {
      #prePanel.panel .section-title {
        display: block;
      }
    }

    footer {
      text-align: center;
      font-size: 14px;
      color: var(--muted);
      padding: 30px 10px;
      border-top: 1px solid var(--line);
      margin-top: 40px;
    }

    footer a {
      color: var(--muted);
      /* same gray tone as the footer text */
      text-decoration: none;
      /* remove underline */
    }

    footer a:hover {
      color: var(--accent);
      /* green accent on hover */
      text-decoration: underline;
      /* optional: subtle underline */
    }
  </style>
</head>

<body>

  <div class="logo-container">
    <a href="https://carpaudio.com/" aria-label="CARP Audio home">
      <img src="icons/ss-logo.svg" alt="Sample Scratcher Logo" class="ss-logo" />
    </a>
  </div>

  <main>
    <!-- 1) Load Sample – full dropzone with centered refined recording controls -->
    <section class="panel elev" id="loadPanel">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drag and drop audio here or browse files">
        <div class="dz-inner">
          <span class="big-plus">+</span>
          <div class="dz-title">Drag & Drop Sample</div>
          <div><span class="dz-browse" id="browseLink">Or Browse Files</span></div>
          <input id="fileInput" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="rec-controls-wrap">
        <div class="rec-controls">
          <button id="recordBtn" class="round-icon" title="Record"><span class="record-dot"></span></button>
          <button id="stopBtn" class="round-icon" title="Stop" disabled><span class="stop-square"></span></button>
        </div>
        <div class="rec-status" id="recStatus">No sample loaded…</div>
      </div>
    </section>

    <section class="panel" id="prePanel">
      <div class="section-title">
        <h2 id="fileSubtitle"></h2>
        <div class="row" style="margin-bottom: 10px;">
          <button id="reloadSampleBtn" class="tiny pill ghost" disabled>Reset</button>
          <button id="commitPreBtn" class="tiny pill primary" disabled>Cut Sample</button>
          <button id="prePlayBtn" class="round-icon small" title="Preview" disabled>
            <div class="icon icon-play"></div>
          </button>
        </div>
      </div>
      <canvas id="preCanvas" width="900" height="80"></canvas>
      <div class="handles">
        <span>Start: <span id="preStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="preLenLbl" class="value">0.00s</span></span>
        <span>End: <span id="preEndLbl">0.00s</span></span>
      </div>
    </section>

    <!-- 3) Scratching Area -->
    <section class="panel">
      <div class="section-title">
        <h2>Scratch Area</h2>
      </div>
      <canvas id="waveCanvas" width="900" height="160" aria-label="Scratching waveform"></canvas>
      <div class="handles">
        <span>Start: <span id="clipStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="clipLenLbl" class="value">0.10s</span></span>
        <span>End: <span id="clipEndLbl">0.10s</span></span>
      </div>
    </section>

    <!-- 4) Settings -->
    <section class="panel" id="settingsPanel">
      <div class="section-title">
        <h2>Sample Generation</h2>
      </div>
      <div class="settings-row">
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">BPM</span>
          <input id="bpm" type="number" value="120" min="40" max="300" step="1" />
        </div>
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">Continue Playback</span>
          <label class="switch" title="Continue Playback after Scratching">
            <input id="slipMode" type="checkbox" />
            <span class="slider round"></span>
          </label>
        </div>
        <div class="field switch-field">
          <span style="padding:7px" class="switch-label">Vinyl Noise</span>
          <label class="switch" title="Scratch with Dusty Vinyl">
            <input id="vinylNoise" type="checkbox" checked />
            <span class="slider round"></span>
          </label>
        </div>
        <div class="field switch-field">
          <span style="padding:7px" class="switch-label">Humanize</span>
          <label class="switch" title="Add subtle human imperfections to scratching">
            <input id="humanizeScratch" type="checkbox" checked />
            <span class="slider round"></span>
          </label>
        </div>
        <button id="generateBtn" class="primary"
          style="font-size:20px; margin-left:auto; margin-right: 3px; padding:10px 90px 10px 90px; border-radius:999px; font-family: Oswald, sans-serif;"
          disabled>
          Generate Samples
        </button>
      </div>
    </section>

    <!-- 5) Effects -->
    <section class="panel" id="effectsPanel">
      <div id="presetGrid" class="preset-grid"></div>
    </section>
  </main>

  <template id="presetCardTpl">
    <div class="preset-card">
      <div class="section-title">
        <div class="left-group">
          <h3 class="pname"></h3>
          <button class="option-pill hidden no-hover" title="Variation">Option</button>
          <button class="reload-btn no-hover" title="Render Again">
            <svg width="800px" height="800px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none">
              <path fill="#ffffff"
                d="M7.248 1.307A.75.75 0 118.252.193l2.5 2.25a.75.75 0 010 1.114l-2.5 2.25a.75.75 0 01-1.004-1.114l1.29-1.161a4.5 4.5 0 103.655 2.832.75.75 0 111.398-.546A6 6 0 118.018 2l-.77-.693z" />
            </svg>
          </button>
        </div>
        <span class="beat-icon" title="Beat(s)"></span>
      </div>
      <div class="mini-wrap">
        <canvas class="mini-wave" width="300" height="54"></canvas>
      </div>
      <div class="meta">
        Duration: <span class="duration"></span>
      </div>
      <div class="preset-actions">
        <button class="playBtn primary">Play</button>
        <button class="dlBtn btn-ghost">Download</button>
      </div>
    </div>
  </template>

  <div class="screen-overlay-container">
    <div class="bubble-container" id="bubbleContainer"></div>
  </div>

  <footer>
    © 2025. <a href="https://carpaudio.com/" title="">CARP Audio</a>. All rights reserved.
  </footer>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let mediaRecorder, chunks = [];
    let mediaStream = null;
    let sampleBuffer = null;
    let originalSampleBuffer = null;
    let sampleFileName = '';

    let preStart = 0, preEnd = 0;
    let clipStart = 0, clipEnd = 0.10;

    let rafId = null;
    let playhead = { active: false, startAt: 0, duration: 0, where: 'none', canvas: null, miniIdx: -1 };

    let mainSrc = null;

    let presetSrc = null;

    let presetBuffers = [];

    let presetBeats = [];

    let lastGeneratedWithSlip = false; // onthoud slip state bij Generate

    const slipModeEl = document.getElementById('slipMode');

    const recStatus = document.getElementById('recStatus');
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const browseLink = document.getElementById('browseLink');

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recControls = document.querySelector('.rec-controls');
    let recTimerInterval = null;
    let recStartTime = null;

    const fileSubtitle = document.getElementById('fileSubtitle');
    const preCanvas = document.getElementById('preCanvas');
    const preCtx = preCanvas.getContext('2d');
    const preStartLbl = document.getElementById('preStartLbl');
    const preEndLbl = document.getElementById('preEndLbl');
    const preLenLbl = document.getElementById('preLenLbl');
    const reloadSampleBtn = document.getElementById('reloadSampleBtn');
    const prePlayBtn = document.getElementById('prePlayBtn');
    const commitPreBtn = document.getElementById('commitPreBtn');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');
    const clipStartLbl = document.getElementById('clipStartLbl');
    const clipEndLbl = document.getElementById('clipEndLbl');
    const clipLenLbl = document.getElementById('clipLenLbl');

    const bpmEl = document.getElementById('bpm');
    const globalStatus = document.getElementById('globalStatus');

    const presetGrid = document.getElementById('presetGrid');
    const presetCardTpl = document.getElementById('presetCardTpl');

    const generateBtn = document.getElementById('generateBtn');

    const humanizeScratchEl = document.getElementById('humanizeScratch');

    // === Make BPM field draggable (scrubbable) ===
    let bpmDragActive = false;
    let bpmStartY = 0;
    let bpmStartValue = 0;

    bpmEl.style.cursor = 'ns-resize'; // up/down cursor for hint

    bpmEl.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // left-click only
      bpmDragActive = true;
      bpmStartY = e.clientY;
      bpmStartValue = parseFloat(bpmEl.value) || 120;
      document.body.style.userSelect = 'none'; // prevent text highlighting
    });

    window.addEventListener('mousemove', (e) => {
      if (!bpmDragActive) return;

      const deltaY = bpmStartY - e.clientY; // dragging up increases BPM
      const sensitivity = 0.25; // adjust for finer or faster control
      let newBpm = bpmStartValue + deltaY * sensitivity;

      newBpm = Math.round(newBpm);
      newBpm = Math.max(40, Math.min(300, newBpm)); // clamp to input range
      bpmEl.value = newBpm;
    });

    window.addEventListener('mouseup', () => {
      if (bpmDragActive) {
        bpmDragActive = false;
        document.body.style.userSelect = '';
      }
    });

    // Vinyl Noise
    const vinylNoiseEl = document.getElementById('vinylNoise');
    const VINYL_NOISE_VOLUME = 0.20; // hardcoded: lager = subtieler

    let noiseBuffers = [];

    // ==== helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function sampleLinear(chData, pos) { const i = Math.floor(pos), f = pos - i; const i2 = Math.min(chData.length - 1, i + 1); return lerp(chData[i] || 0, chData[i2] || 0, f); }
    // Higher-quality interpolation (4-point cubic Hermite)
    function sampleCubic(chData, pos) {
      const i = Math.floor(pos);
      const frac = pos - i;

      const y0 = chData[i - 1] || 0;
      const y1 = chData[i] || 0;
      const y2 = chData[i + 1] || 0;
      const y3 = chData[i + 2] || 0;

      const a = (-0.5 * y0) + (1.5 * y1) - (1.5 * y2) + (0.5 * y3);
      const b = y0 - (2.5 * y1) + (2 * y2) - (0.5 * y3);
      const c = (-0.5 * y0) + (0.5 * y2);
      const d = y1;

      return a * frac * frac * frac + b * frac * frac + c * frac + d;
    }
    function secToX(sec, duration, width) { const ratio = duration ? (sec / duration) : 0; return Math.round(clamp(ratio, 0, 1) * (width - 1)); }
    function xToSec(x, duration, width) { const ratio = x / (width - 1); return ratio * (duration || 0); }

    function fitCanvasToDisplay(canvas) { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); const need = canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr); if (need) { canvas.width = Math.max(1, Math.round(rect.width * dpr)); canvas.height = Math.max(1, Math.round(rect.height * dpr)); } return dpr; }
    function canvasEventX(e, canvas) { const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect(); return clamp((e.clientX - r.left) * dpr, 0, canvas.width - 1); }

    function updateLabels() {
      clipStartLbl.textContent = (clipStart || 0).toFixed(2) + 's';
      clipEndLbl.textContent = (clipEnd || 0).toFixed(2) + 's';
      clipLenLbl.textContent = Math.max(0, (clipEnd - clipStart)).toFixed(2) + 's';

      preStartLbl.textContent = (preStart || 0).toFixed(2) + 's';
      preEndLbl.textContent = (preEnd || 0).toFixed(2) + 's';

      const preLen = Math.max(0, (preEnd - preStart));
      const lenStr = preLen.toFixed(2) + 's';
      preLenLbl.textContent = (Math.abs(preLen - 10) < 0.005) ? `${lenStr} (Max)` : lenStr;
    }

    // ==== drawing
    function drawPreWave() {
      const dpr = fitCanvasToDisplay(preCanvas);
      const Wp = preCanvas.width, Hp = preCanvas.height;
      preCtx.clearRect(0, 0, Wp, Hp);
      preCtx.fillStyle = '#121212';
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      preCtx.fillRect(0, 0, Wp, Hp);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wp));
      preCtx.strokeStyle = '#666';
      preCtx.lineWidth = Math.max(1, dpr);
      preCtx.beginPath();
      for (let x = 0; x < Wp; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * Hp;
        if (x === 0) preCtx.moveTo(x, y); else preCtx.lineTo(x, y);
      }
      preCtx.stroke();

      // Draw selection shading + handles
      const sX = secToX(preStart, sampleBuffer.duration, Wp);
      const eX = secToX(preEnd, sampleBuffer.duration, Wp);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      preCtx.fillStyle = 'rgba(34,197,94,0.18)';
      preCtx.fillRect(a, 0, Math.max(1, b - a), Hp);

      preCtx.strokeStyle = '#22c55e';
      preCtx.lineWidth = Math.max(2, 2 * dpr);
      preCtx.beginPath(); preCtx.moveTo(sX, 0); preCtx.lineTo(sX, Hp); preCtx.stroke();
      preCtx.beginPath(); preCtx.moveTo(eX, 0); preCtx.lineTo(eX, Hp); preCtx.stroke();

      // --- FIXED: playhead line ---
      if (playhead.active && playhead.where === 'pre') {
        const elapsed = audioCtx.currentTime - playhead.startAt;
        const rel = Math.min(elapsed, playhead.duration);   // clamp to selection length
        const x = secToX(preStart + rel, sampleBuffer.duration, Wp);
        preCtx.strokeStyle = '#ffffff';
        preCtx.lineWidth = Math.max(1, dpr);
        preCtx.beginPath();
        preCtx.moveTo(x, 0);
        preCtx.lineTo(x, Hp);
        preCtx.stroke();
      }
    }

    function drawMainWave() {
      const dpr = fitCanvasToDisplay(waveCanvas);
      const Wc = waveCanvas.width, Hc = waveCanvas.height;
      waveCtx.clearRect(0, 0, Wc, Hc);
      waveCtx.fillStyle = '#121212'; waveCtx.fillRect(0, 0, Wc, Hc);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wc));
      waveCtx.strokeStyle = '#16a34a';
      waveCtx.lineWidth = Math.max(1, dpr);
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      waveCtx.beginPath();
      for (let x = 0; x < Wc; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hc; if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y); }
      waveCtx.stroke();

      const sX = secToX(clipStart, sampleBuffer.duration, Wc), eX = secToX(clipEnd, sampleBuffer.duration, Wc);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)'; waveCtx.fillRect(a, 0, Math.max(1, b - a), Hc);

      waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = Math.max(2, 2 * dpr);
      waveCtx.beginPath(); waveCtx.moveTo(sX, 0); waveCtx.lineTo(sX, Hc); waveCtx.stroke();
      waveCtx.beginPath(); waveCtx.moveTo(eX, 0); waveCtx.lineTo(eX, Hc); waveCtx.stroke();

      // Play circle only (white mid bar removed for easier drag)
      const midX = Math.round((a + b) / 2);
      const r = 14 * dpr; const cy = Hc / 2;
      const isPlaying = playhead.active && playhead.where === 'main';
      waveCtx.beginPath(); waveCtx.arc(midX, cy, r, 0, Math.PI * 2); waveCtx.fillStyle = '#111'; waveCtx.fill(); waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = 2 * dpr; waveCtx.stroke();
      waveCtx.fillStyle = '#fff';
      if (!isPlaying) { const px = midX - 5 * dpr, py = cy - 7 * dpr; waveCtx.beginPath(); waveCtx.moveTo(px, py); waveCtx.lineTo(px, py + 14 * dpr); waveCtx.lineTo(px + 12 * dpr, cy); waveCtx.closePath(); waveCtx.fill(); }
      else {
        const size = 12 * dpr;
        waveCtx.fillRect(midX - size / 2, cy - size / 2, size, size);
      }

      if (playhead.active && playhead.where === 'main') {
        const p = clamp((audioCtx.currentTime - playhead.startAt) / playhead.duration, 0, 1);
        const x = a + p * (b - a);
        waveCtx.strokeStyle = '#ffffff'; waveCtx.lineWidth = Math.max(1, dpr);
        waveCtx.beginPath(); waveCtx.moveTo(x, 0); waveCtx.lineTo(x, Hc); waveCtx.stroke();
      }
    }

    function drawMiniFromBuffer(canvas, buffer, playPct = null, beats = 1) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212';
      ctx.fillRect(0, 0, w, h);
      if (!buffer) return;

      // waveform tekenen
      const data = buffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / w));
      ctx.strokeStyle = '#16a34a';
      ctx.lineWidth = Math.max(1, dpr);
      ctx.shadowColor = '#22c55e4A';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * h;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // beat-lijntjes tekenen (alleen als slip uit stond bij generate)
      if (!lastGeneratedWithSlip && beats > 1) {
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 0.5 * dpr;
        for (let b = 1; b < beats; b++) {
          const x = Math.round((b / beats) * w);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
      }

      // playhead tekenen
      if (playPct != null) {
        const x = clamp(Math.round(playPct * (w - 1)), 0, w - 1);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, dpr);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
    }


    function drawCurve(canvas, arr, lo, hi, label) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212'; ctx.fillRect(0, 0, w, h);
      if (!arr) return;
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let i = 0; i < w; i++) {
        const t = w > 1 ? i / (w - 1) : 0; const idx = Math.floor(t * (arr.length - 1));
        const v = arr[idx];
        const y = (1 - (v - lo) / (hi - lo)) * h;
        if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
      }
      ctx.stroke();
      // subtle label inside
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      ctx.font = `${12 * dpr}px system-ui, sans-serif`;
      const text = label || '';
      if (text) ctx.fillText(text, 10 * dpr, 18 * dpr);
    }

    async function loadNoiseBuffers() {
      const bufs = [];
      for (let i = 1; i <= 10; i++) {
        const url = `noise/noise${String(i).padStart(2, '0')}.wav`;
        const res = await fetch(url);
        const arr = await res.arrayBuffer();
        const buf = await audioCtx.decodeAudioData(arr);
        bufs.push(buf);
      }
      noiseBuffers = bufs;
      console.log("Loaded noise samples:", noiseBuffers.length);
    }

    function mixWithNoise(mainBuffer) {
      if (!vinylNoiseEl.checked || noiseBuffers.length === 0) return mainBuffer;

      // random noise sample
      const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
      const noiseOffset = Math.floor(Math.random() * noise.length);

      // nieuwe buffer voor mix
      const mixed = audioCtx.createBuffer(
        mainBuffer.numberOfChannels,
        mainBuffer.length,
        mainBuffer.sampleRate
      );

      for (let ch = 0; ch < mainBuffer.numberOfChannels; ch++) {
        const mainData = mainBuffer.getChannelData(ch);
        const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
        const mixedData = mixed.getChannelData(ch);

        for (let i = 0; i < mainBuffer.length; i++) {
          const n = noiseData[(i + noiseOffset) % noise.length]; // random start
          mixedData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
        }
      }
      return mixed;
    }

    // ==== load / record
    async function loadArrayBuffer(arr, name = '') {
      const decoded = await audioCtx.decodeAudioData(arr);

      const maxSizeMB = 200;
      if (arr.byteLength > maxSizeMB * 1024 * 1024) {
        recStatus.textContent = `File too large (${(arr.byteLength / 1024 / 1024).toFixed(1)} MB). Max allowed is ${maxSizeMB} MB.`;
        return;
      }

      sampleBuffer = decoded;
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;

      // default selection
      preStart = 0;
      preEnd = Math.min(1, sampleBuffer.duration);
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      // === enforce 10-second rule ===
      if (sampleBuffer.duration > 10) {
        recStatus.innerHTML = 'Please cut a sample from the file! (<span style="color:#22c55e;">Max 10s</span>)';
        disableScratchArea(true);        // hide / disable scratch canvas
        commitPreBtn.disabled = false;
        reloadSampleBtn.disabled = false;
        prePlayBtn.disabled = false;
        generateBtn.disabled = true;

        // draw only the preselection waveform
        drawPreWave();

        // clear scratch area so no waveform is visible
        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
        waveCtx.fillStyle = '#121212';
        waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
        const message = 'Cut a sample from the audio file. (Max 10s)';

        // Device pixel ratio for sharpness
        const dpr = window.devicePixelRatio || 1;

        // Smaller, more balanced font scaling
        // ~12px on phones, ~16px on desktop (before DPR scaling)
        const baseFont = window.innerWidth < 600 ? 12 : 16;
        waveCtx.font = `${baseFont * dpr}px system-ui`;
        waveCtx.fillStyle = '#777';

        // Optional soft shadow for readability
        waveCtx.shadowColor = 'rgba(0,0,0,0.3)';
        waveCtx.shadowBlur = 2;

        // Center message
        const metrics = waveCtx.measureText(message);
        const x = (waveCanvas.width - metrics.width) / 2;
        const y = (waveCanvas.height / 2) + baseFont * dpr * 0.4;
        waveCtx.fillText(message, x, y);

        waveCtx.fillText(message, x, y);
      } else {
        recStatus.textContent = `Sample: ${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate} Hz`;
        disableScratchArea(false);
        commitPreBtn.disabled = false;
        reloadSampleBtn.disabled = false;
        prePlayBtn.disabled = false;
        generateBtn.disabled = false;

        // draw both
        drawPreWave();
        drawMainWave();
      }

      updateLabels();
      updateTouchAction();
    }

    function disableScratchArea(disabled) {
      const waveCanvas = document.getElementById('waveCanvas');
      if (disabled) {
        waveCanvas.style.pointerEvents = 'none';
        generateBtn.disabled = true;
      } else {
        waveCanvas.style.pointerEvents = 'auto';
      }
    }

    dropzone.addEventListener('click', () => fileInput.click());
    browseLink.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
    dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', async (e) => { e.preventDefault(); dropzone.classList.remove('hover'); const file = e.dataTransfer.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); });
    fileInput.onchange = async (e) => { const file = e.target.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); };

    const startRecording = async () => {
      await audioCtx.resume();

      if (!mediaStream || !mediaStream.active) {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      }

      mediaRecorder = new MediaRecorder(mediaStream);
      chunks = [];

      mediaRecorder.ondataavailable = e => e.data && chunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
        const arr = await blob.arrayBuffer();
        await loadArrayBuffer(arr, 'Recorded Sample');
      };

      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;

      recControls.classList.remove('idle');
      recControls.classList.add('recording');

      recStartTime = Date.now();
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = setInterval(() => {
        const elapsed = ((Date.now() - recStartTime) / 1000).toFixed(1);
        recStatus.textContent = `Recording… ${elapsed}s`;
      }, 200);
    };
    recordBtn.onclick = startRecording;
    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }

      stopBtn.disabled = true;
      recordBtn.disabled = false;

      recControls.classList.remove('recording');
      recControls.classList.add('idle');

      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = null;

      recStatus.textContent = 'Stopped. Processing sample…';
    };

    // ==== Preselection interactions
    let preDragging = null; // 'start' | 'end' | 'move' | 'new'
    const HANDLE_EPS = 12 * (window.devicePixelRatio || 1);

    function preHitTest(x) {
      const sX = secToX(preStart, sampleBuffer?.duration, preCanvas.width);
      const eX = secToX(preEnd, sampleBuffer?.duration, preCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updatePreCursor(e) { if (!sampleBuffer) { preCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, preCanvas); const kind = preHitTest(x); preCanvas.style.cursor = (kind === 'move') ? 'grab' : (kind === 'start' || kind === 'end') ? 'ew-resize' : 'crosshair'; }

    preCanvas.addEventListener('pointermove', (e) => {
      if (!preDragging) updatePreCursor(e);
      if (!sampleBuffer || !preDragging) return;

      const x = canvasEventX(e, preCanvas);
      const sec = xToSec(x, sampleBuffer.duration, preCanvas.width);
      const MAX_LEN = 10; // limit preselection to 10 seconds

      if (preDragging === 'start') {
        preStart = Math.min(sec, preEnd - 0.005);
        if (preEnd - preStart > MAX_LEN) {
          preStart = preEnd - MAX_LEN;
        }
      } else if (preDragging === 'end') {
        preEnd = Math.max(sec, preStart + 0.005);
        if (preEnd - preStart > MAX_LEN) {
          preEnd = preStart + MAX_LEN;
        }
      } else if (preDragging === 'move') {
        const width = Math.min(preEnd - preStart, MAX_LEN);
        let ns = sec - width / 2;
        ns = clamp(ns, 0, sampleBuffer.duration - width);
        preStart = ns;
        preEnd = ns + width;
      } else if (preDragging === 'new') {
        // new drag selection
        preEnd = sec;
        if (preEnd < preStart) {
          [preStart, preEnd] = [preEnd, preStart];
        }
        // clamp if dragged too far
        if (preEnd - preStart > MAX_LEN) {
          preEnd = preStart + MAX_LEN;
        }
      }

      // keep inside buffer duration
      preStart = clamp(preStart, 0, sampleBuffer.duration);
      preEnd = clamp(preEnd, 0, sampleBuffer.duration);

      drawPreWave();
      updateLabels();
    });

    preCanvas.addEventListener('pointerdown', (e) => { if (!sampleBuffer) return; preCanvas.setPointerCapture(e.pointerId); const x = canvasEventX(e, preCanvas); const ht = preHitTest(x); if (ht === 'new') { const sec = xToSec(x, sampleBuffer.duration, preCanvas.width); preStart = sec; preEnd = sec; } preDragging = ht; updatePreCursor(e); });
    preCanvas.addEventListener('pointerup', (e) => { preDragging = null; preCanvas.releasePointerCapture(e.pointerId); updatePreCursor(e); });
    preCanvas.addEventListener('pointerleave', () => { preDragging = null; preCanvas.style.cursor = 'crosshair'; });

    let preSrc = null;

    function setPreBtnState(state) {
      prePlayBtn.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'icon';

      if (state === 'play') {
        const icon = document.createElement('div');
        icon.className = 'icon-play';
        wrapper.appendChild(icon);
      } else if (state === 'stop') {
        const icon = document.createElement('div');
        icon.className = 'icon-stop';
        wrapper.appendChild(icon);
      }

      prePlayBtn.appendChild(wrapper);
    }

    prePlayBtn.onclick = () => {
      if (!sampleBuffer) return;

      if (preSrc) {
        // already playing → stop
        preSrc.stop();
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
        return;
      }

      // create new buffer with selection
      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
      };

      src.start();
      preSrc = src;
      setPreBtnState('stop');
      startPlayhead('pre', (preEnd - preStart));
    };

    commitPreBtn.onclick = () => {
      if (!sampleBuffer) return;

      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));

      const newBuf = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = newBuf.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }

      sampleBuffer = newBuf;
      preStart = 0;
      preEnd = sampleBuffer.duration;
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      if (sampleBuffer.duration <= 10) {
        recStatus.textContent = `Audio file has been cut to a ${sampleBuffer.duration.toFixed(2)}s sample.`;
        disableScratchArea(false);
        generateBtn.disabled = false;
      } else {
        recStatus.textContent = "Please cut the sample to 10 seconds or shorter.";
        disableScratchArea(true);
      }

      drawPreWave();
      drawMainWave();
      updateLabels();
    };

    reloadSampleBtn.onclick = () => {
      if (!originalSampleBuffer) return;

      // Restore the full original audio for preselection
      sampleBuffer = originalSampleBuffer;
      preStart = 0;
      preEnd = Math.min(1, sampleBuffer.duration);
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      // If file is longer than 10s → disable scratching again
      if (sampleBuffer.duration > 10) {
        recStatus.innerHTML = `Full file reloaded (${sampleBuffer.duration.toFixed(2)}s). Please cut a sample again! <span style="color:#22c55e;">(Max 10s)</span>`;
        disableScratchArea(true);

        // Clear the scratch waveform
        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
        waveCtx.fillStyle = '#121212';
        waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);

        const msg = 'Cut a sample from the audio file. (Max 10s)';

        // Device pixel ratio for sharpness
        const dpr = window.devicePixelRatio || 1;

        // Balanced font scaling: ~12px mobile, ~16px desktop
        const baseFont = window.innerWidth < 600 ? 12 : 16;
        waveCtx.font = `${baseFont * dpr}px system-ui`;
        waveCtx.fillStyle = '#777';

        // Optional shadow for readability
        waveCtx.shadowColor = 'rgba(0,0,0,0.3)';
        waveCtx.shadowBlur = 2;

        // Center text on canvas
        const metrics = waveCtx.measureText(msg);
        const x = (waveCanvas.width - metrics.width) / 2;
        const y = (waveCanvas.height / 2) + baseFont * dpr * 0.4;
        waveCtx.fillText(msg, x, y);

        generateBtn.disabled = true;
      } else {
        // Short files can be used directly
        recStatus.textContent = `Sample ready (${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate}Hz)`;
        disableScratchArea(false);
        drawMainWave();
        generateBtn.disabled = false;
      }

      drawPreWave();
      updateLabels();
      recStatus.textContent = `Full original file reloaded (${sampleBuffer.duration.toFixed(2)}s).`;
    };


    // ==== main selection with play circle (no visible mid bar)
    let dragging = null; // 'start' | 'end' | 'move'
    const MAIN_HANDLE_EPS = 14 * (window.devicePixelRatio || 1);

    function isInsidePlayCircle(x, y) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      const midX = (a + b) / 2;
      const cy = waveCanvas.height / 2;

      const dpr = (window.devicePixelRatio || 1);
      const r = 14 * dpr;

      // echte afstand check
      const dx = x - midX;
      const dy = y - cy;
      return dx * dx + dy * dy <= r * r;
    }

    function mainHitTest(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);

      if (Math.abs(x - sX) <= MAIN_HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= MAIN_HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updateMainCursor(e) {
      if (!sampleBuffer) {
        waveCanvas.style.cursor = 'not-allowed';
        return;
      }

      const x = canvasEventX(e, waveCanvas);
      const y = (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1);

      // Check playbutton eerst
      if (isInsidePlayCircle(x, y)) {
        waveCanvas.style.cursor = 'pointer';
        return;
      }

      const ht = mainHitTest(x);

      if (ht === 'move') {
        waveCanvas.style.cursor = 'grab';
      } else if (ht === 'start' || ht === 'end') {
        waveCanvas.style.cursor = 'ew-resize';
      } else if (ht === 'new') {
        waveCanvas.style.cursor = 'crosshair'; // vrij selecteren
      } else {
        waveCanvas.style.cursor = 'default';
      }
    }

    waveCanvas.addEventListener('pointerdown', (e) => {
      if (!sampleBuffer) return;
      waveCanvas.setPointerCapture(e.pointerId);
      const x = canvasEventX(e, waveCanvas);
      if (isInsidePlayCircle(x, (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1))) {
        if (playhead.active && playhead.where === 'main') {
          stopPlayhead();
        } else {
          playClipSelection();
        }
        return;
      }
      const ht = mainHitTest(x);
      if (ht === 'new') {
        const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
        clipStart = sec;
        clipEnd = sec;
      }
      dragging = ht;
    });
    waveCanvas.addEventListener('pointermove', (e) => {
      if (!dragging) updateMainCursor(e);
      if (!sampleBuffer || !dragging) return;
      const x = canvasEventX(e, waveCanvas);
      const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
      if (dragging === 'start') clipStart = Math.min(sec, clipEnd - 0.005);
      else if (dragging === 'end') clipEnd = Math.max(sec, clipStart + 0.005);
      else if (dragging === 'move') { const width = clipEnd - clipStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); clipStart = ns; clipEnd = ns + width; }
      else if (dragging === 'new') {
        clipEnd = Math.max(sec, 0);
        clipStart = Math.min(sec, clipStart);
      }
      drawMainWave(); updateLabels();
    });
    waveCanvas.addEventListener('pointerup', (e) => { dragging = null; waveCanvas.releasePointerCapture(e.pointerId); updateMainCursor(e); });
    waveCanvas.addEventListener('pointerleave', () => { dragging = null; waveCanvas.style.cursor = 'crosshair'; });

    function playClipSelection() {
      if (!sampleBuffer) return;

      // stop eventueel vorige afspeler
      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((clipEnd - clipStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(clipStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        mainSrc = null;
        stopPlayhead();
      };

      src.start();
      mainSrc = src;

      startPlayhead('main', (clipEnd - clipStart));
    }

    function curveFromFormula(formula, samples, lo, hi) {
      let fn; try { fn = new Function('t', `return (${formula});`); } catch (err) { throw new Error('Formula error: ' + err.message); }
      const arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) { const t = samples > 1 ? i / (samples - 1) : 0; let v; try { v = fn(t); } catch (e) { v = 0; } if (!Number.isFinite(v)) v = 0; arr[i] = clamp(v, lo, hi); }
      return arr;
    }

    async function renderEffectToBuffer(preset) {
      if (!sampleBuffer) throw new Error('No sample loaded or recorded.');

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchFormula = preset.activeScratchFormula || preset.scratchFormula;
      const gainFormula = preset.activeGainFormula || preset.gainFormula;
      let scratchCurve = curveFromFormula(scratchFormula, scratchSamples, -1, 1);

      // Apply humanization if enabled
      if (humanizeScratchEl.checked) {
        scratchCurve = humanizeScratchCurve(scratchCurve);
      }
      const gainCurve = curveFromFormula(gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: bouw scratchInput buffer (sample + noise als één bron) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];

        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );

        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);

          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length]; // loop de noise
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = new AudioBuffer({
        length: scratchSamples,
        numberOfChannels: scratchInput.numberOfChannels,
        sampleRate: sr
      });

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }

        if (scratchSamples > 0) {
          const v = sampleCubic(inData, lastPos);
          outData[scratchSamples - 1] = v * gainCurve[scratchSamples - 1];
        }

        // Fade in/out (anti-click)
        const fadeSamples = Math.floor(sr * 0.05);
        for (let i = 0; i < fadeSamples; i++) {
          const t = i / fadeSamples;
          outData[i] *= t;
          const j = outData.length - 1 - i;
          if (j >= 0) outData[j] *= t;
        }
      }

      // === Stap 3: Slip Mode continuation ===
      if (slipModeEl.checked) {
        const sr = scratchInput.sampleRate;

        // Calculate lengths
        const scratchLen = out.length;
        const normalStart = Math.floor(clipStart * sr);
        const normalEnd = Math.floor(sampleBuffer.duration * sr);
        const normalLen = normalEnd - normalStart;

        // Make new buffer big enough for scratch + normal continuation
        const extended = new AudioBuffer({
          length: scratchLen + normalLen,
          numberOfChannels: out.numberOfChannels,
          sampleRate: sr
        });

        // Copy scratch effect
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Append clean playback from clipStart → preEnd
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);

          for (let i = 0; i < normalLen; i++) {
            const srcIdx = normalStart + i;
            extData[scratchLen + i] = inData[srcIdx] || 0;
          }
        }

        out = extended;
      }

      // === Stap 4: render in OfflineAudioContext ===
      return out;
    }

    // ==== Presets
    let presets = [];

    async function loadPresets() {
      try {
        const res = await fetch("scratches.json");
        presets = await res.json();

        // ✅ Zet standaard actieve formules
        presets.forEach(p => {
          p.activeScratchFormula = p.scratchFormula;
          p.activeGainFormula = p.gainFormula;
        });

        console.log("Scratch curves loaded:", presets);

        // Now initialize UI only after presets exist
        init();
      } catch (err) {
        console.error("Failed to load scratch curves:", err);
      }
    }

    function init() {
      fitCanvasToDisplay(preCanvas);
      fitCanvasToDisplay(waveCanvas);
      drawPreWave();
      drawMainWave();
      updateLabels();
      renderPresetGrid();
      recControls.classList.add('idle');
      setPreBtnState('play');
    }

    async function renderPresetGrid() {
      presetGrid.innerHTML = '';

      // --- één globale popup voor beats ---
      let options = document.querySelector('.beat-options');
      if (!options) {
        options = document.createElement('div');
        options.className = "beat-options";
        Object.assign(options.style, {
          position: "absolute",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
          padding: "6px 10px",
          background: "rgba(20,20,20,0.95)",
          border: "1px solid #333",
          borderRadius: "999px",
          boxShadow: "0 6px 20px rgba(0,0,0,0.5)",
          zIndex: "999999",
          opacity: "0",
          transform: "scale(0.8)",
          pointerEvents: "none",
          transition: "opacity 0.2s ease, transform 0.2s ease"
        });

        [1, 2, 3, 4].forEach(optBeat => {
          const opt = document.createElement('img');
          opt.src = `icons/beat-${optBeat}.svg`;
          opt.alt = `${optBeat} beat`;
          opt.style.width = "28px";
          opt.style.cursor = "pointer";
          options.appendChild(opt);
        });

        document.body.appendChild(options);
      }

      presets.forEach((p, idx) => {
        const node = presetCardTpl.content.cloneNode(true);
        const card = node.querySelector('.preset-card');
        const pnameEl = node.querySelector('.pname');
        pnameEl.textContent = p.name;

        // === OPTIE-PILL DROPDOWN ===
        const pill = node.querySelector('.option-pill');
        const optionsList = Object.keys(p)
          .filter(k => k.toLowerCase().startsWith('option'))
          .map(k => p[k])
          .filter(Boolean);

        if (optionsList.length > 1) {
          pill.classList.remove('hidden');
          const lastChoice = p.selectedOption;
          const defaultOption = lastChoice || p.defaultOption || optionsList[0];
          pill.textContent = defaultOption;

          const index = optionsList.indexOf(defaultOption);
          p.activeScratchFormula = p[`scratchFormula${index === 0 ? '' : index + 1}`];
          p.activeGainFormula = p[`gainFormula${index === 0 ? '' : index + 1}`];

          // maak dropdown
          const menu = document.createElement('div');
          menu.className = 'option-menu';
          optionsList.forEach(opt => {
            const btn = document.createElement('button');
            btn.textContent = opt;
            btn.addEventListener('click', async () => {
              pill.textContent = opt;
              p.selectedOption = opt;
              animatePresetReload(card);
              menu.classList.remove('show');

              // verwijder vorige selectie
              menu.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
              btn.classList.add('selected'); // ✅ highlight gekozen optie

              // stel juiste curves in
              const index = optionsList.indexOf(opt);
              p.activeScratchFormula = p[`scratchFormula${index === 0 ? '' : index + 1}`];
              p.activeGainFormula = p[`gainFormula${index === 0 ? '' : index + 1}`];

              // direct opnieuw renderen
              try {
                const rendered = await renderEffectToBuffer(p);
                presetBuffers[idx] = rendered;

                const durationEl = card.querySelector('.duration');
                if (rendered) durationEl.textContent = `${rendered.duration.toFixed(2)}s`;

                const mini = card.querySelector('.mini-wave');
                const beats = parseInt(p.duration, 10) || 1;
                drawMiniFromBuffer(mini, rendered, null, beats);

                globalStatus.textContent = `${p.name} (${opt}) updated`;
              } catch (err) {
                console.error("Re-render failed:", err);
                globalStatus.textContent = `⚠️ Render failed for ${p.name}`;
              }
            });
            menu.appendChild(btn);
          });
          document.body.appendChild(menu);

          // klikgedrag pill
          pill.addEventListener('click', (e) => {
            e.stopPropagation();
            const rect = pill.getBoundingClientRect();
            menu.style.top = `${rect.bottom + window.scrollY + 6}px`;
            menu.style.left = `${rect.left + window.scrollX}px`;

            const activeOpt = p.selectedOption || defaultOption;
            menu.querySelectorAll('button').forEach(b => {
              if (b.textContent.trim() === activeOpt) {
                b.classList.add('selected');
              } else {
                b.classList.remove('selected');
              }
            });

            if (!menu.classList.contains('show')) {
              menu.classList.add('show');
            } else {
              menu.classList.remove('show');
              menu.style.top = '-9999px';
              menu.style.left = '-9999px';
            }
          });

          // sluit menu bij klik buiten
          document.addEventListener('click', () => {
            menu.classList.remove('show');
            menu.style.top = '-9999px';
            menu.style.left = '-9999px';
          });
        } else {
          pill.classList.add('hidden');
          p.activeScratchFormula = p.scratchFormula;
          p.activeGainFormula = p.gainFormula;
        }

        // === BEAT SELECTOR ===
        const beats = parseInt(p.duration, 10) || 1;
        const currentBeat = presetBeats[idx] || beats;
        const beatIconWrap = node.querySelector('.beat-icon');

        beatIconWrap.innerHTML = `
      <img src="icons/beat-${currentBeat}.svg" alt="${currentBeat} beat" class="beat-svg">
    `;
        beatIconWrap.style.position = "relative";
        beatIconWrap.style.cursor = "pointer";

        let activeBeatIcon = null;

        beatIconWrap.addEventListener("click", (e) => {
          e.stopPropagation();

          // toggle popup
          if (activeBeatIcon === beatIconWrap) {
            options.style.opacity = "0";
            options.style.transform = "scale(0.8)";
            options.style.pointerEvents = "none";
            activeBeatIcon = null;
            return;
          }

          activeBeatIcon = beatIconWrap;
          const rect = beatIconWrap.getBoundingClientRect();
          options.style.top = (window.scrollY + rect.top - options.offsetHeight - 8) + "px";
          options.style.left = (window.scrollX + rect.left + rect.width / 2 - options.offsetWidth / 2) + "px";

          const currentBeat = presetBeats[idx] || parseInt(p.duration, 10) || 1;
          options.querySelectorAll('img').forEach(img => {
            const optBeat = parseInt(img.alt, 10);
            if (optBeat === currentBeat) {
              img.style.opacity = "1";
              img.style.transform = "scale(1.1)";
            } else {
              img.style.opacity = "0.2";
              img.style.transform = "scale(1)";
            }
          });

          options.style.opacity = "1";
          options.style.transform = "scale(1)";
          options.style.pointerEvents = "auto";

          // klik op beat icoon
          options.querySelectorAll('img').forEach(opt => {
            opt.onclick = async (ev) => {
              ev.stopPropagation();
              animatePresetReload(card);
              const optBeat = parseInt(opt.alt, 10);

              presets[idx].duration = optBeat;

              try {
                const rendered = await renderEffectToBuffer(presets[idx]);
                presetBuffers[idx] = rendered;
                presetBeats[idx] = optBeat;
              } catch (err) {
                console.error("Re-render failed:", err);
              }

              const durationEl = card.querySelector('.duration');
              if (presetBuffers[idx]) {
                durationEl.textContent = `${presetBuffers[idx].duration.toFixed(2)}s`;
              }
              const beatIconImg = card.querySelector('.beat-svg');
              beatIconImg.src = `icons/beat-${optBeat}.svg`;
              beatIconImg.alt = `${optBeat} beat`;

              const mini = card.querySelector('.mini-wave');
              if (presetBuffers[idx]) {
                drawMiniFromBuffer(mini, presetBuffers[idx], null, optBeat);
              }

              options.style.opacity = "0";
              options.style.transform = "scale(0.8)";
              options.style.pointerEvents = "none";
              activeBeatIcon = null;
            };
          });
        });

        // === duur + mini-wave ===
        if (presetBuffers[idx]) {
          node.querySelector('.duration').textContent = `${presetBuffers[idx].duration.toFixed(2)}s`;
        } else {
          const bpm = parseFloat(bpmEl.value || '120');
          const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
          node.querySelector('.duration').textContent = `${(beatDur * currentBeat).toFixed(2)}s`;
        }

        const mini = node.querySelector('.mini-wave');
        if (sampleBuffer) {
          const preview = synthesizePreviewBuffer(p);
          drawMiniFromBuffer(mini, preview, null, currentBeat);
        }

        // === knoppen ===
        const playBtn = node.querySelector('.playBtn');
        const dlBtn = node.querySelector('.dlBtn');
        playBtn.addEventListener('click', async () => {
          await handlePlayPreset(idx, playBtn, mini);
        });
        dlBtn.addEventListener('click', async () => {
          await handleDownloadPreset(idx);
        });
        mini.addEventListener('click', async () => {
          await handlePlayPreset(idx, playBtn, mini);
        });

        const reloadBtn = node.querySelector('.reload-btn');
        reloadBtn.addEventListener('click', async (e) => {
          animatePresetReload(card);
          e.stopPropagation();
          try {
            const rendered = await renderEffectToBuffer(p);
            presetBuffers[idx] = rendered;

            const durationEl = card.querySelector('.duration');
            durationEl.textContent = `${rendered.duration.toFixed(2)}s`;

            const mini = card.querySelector('.mini-wave');
            const beats = parseInt(p.duration, 10) || 1;
            drawMiniFromBuffer(mini, rendered, null, beats);

            globalStatus.textContent = `${p.name} reloaded.`;
          } catch (err) {
            console.error("Reload failed:", err);
            globalStatus.textContent = `⚠️ Reload failed for ${p.name}`;
          }
        });

        presetGrid.appendChild(node);
      });

      // sluit beat-popup bij klik buiten
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.beat-options') && !e.target.closest('.beat-icon')) {
          options.style.opacity = "0";
          options.style.transform = "scale(0.8)";
          options.style.pointerEvents = "none";
        }
      });
    }

    function synthesizePreviewBuffer(preset) {
      if (!sampleBuffer) return null;

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchFormula = preset.activeScratchFormula || preset.scratchFormula;
      const gainFormula = preset.activeGainFormula || preset.gainFormula;
      let scratchCurve = curveFromFormula(scratchFormula, scratchSamples, -1, 1);

      if (humanizeScratchEl.checked) {
        scratchCurve = humanizeScratchCurve(scratchCurve);
      }
      const gainCurve = curveFromFormula(gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: scratchInput bouwen (sample + noise) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );
        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);
          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length];
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = audioCtx.createBuffer(
        scratchInput.numberOfChannels,
        scratchSamples,
        sr
      );

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }
      }

      // === Stap 3: Slip Mode continuation (ook in preview!) ===
      // === Step 3: Slip Mode continuation (play scratch, then from start of scratch to end of preselection) ===
      if (slipModeEl.checked) {
        const sr = scratchInput.sampleRate;

        // Calculate lengths
        const scratchLen = out.length;
        const normalStart = Math.floor(clipStart * sr);
        const normalEnd = Math.floor(preEnd * sr);
        const normalLen = normalEnd - normalStart;

        // Make new buffer big enough for scratch + normal continuation
        const extended = new AudioBuffer({
          length: scratchLen + normalLen,
          numberOfChannels: out.numberOfChannels,
          sampleRate: sr
        });

        // Copy scratch effect
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Append clean playback from clipStart → preEnd
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);

          for (let i = 0; i < normalLen; i++) {
            const srcIdx = normalStart + i;
            extData[scratchLen + i] = inData[srcIdx] || 0;
          }
        }

        out = extended;
      }


      return out;
    }

    async function updatePresetThumbnails() {

      // Then loop over all preset cards and draw mini-wave previews
      const cards = presetGrid.querySelectorAll('.preset-card');
      cards.forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (!mini) return;
        const preview = synthesizePreviewBuffer(presets[idx]);
        if (preview) {
          drawMiniFromBuffer(mini, preview, null);
        }
      });
    }

    async function handlePlayPreset(i, buttonEl, miniCanvas) {
      try {
        await audioCtx.resume();

        // stop if already playing
        if (presetSrc) {
          presetSrc.stop();
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
          return;
        }

        // use cached buffer
        const rendered = presetBuffers[i];
        if (!rendered) {
          globalStatus.textContent = "Preset not generated yet. Click Generate first!";
          return;
        }

        const src = audioCtx.createBufferSource();
        src.buffer = rendered;
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(12000, audioCtx.currentTime); // cutoff ~12kHz
        src.connect(filter).connect(audioCtx.destination);

        src.onended = () => {
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
        };

        src.start();
        presetSrc = src;

        buttonEl.textContent = 'Stop';
        buttonEl.classList.add('playing');
        startPlayhead('mini', rendered.duration, miniCanvas, i);
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    async function handleDownloadPreset(i) {
      try {
        const rendered = await renderEffectToBuffer(presets[i]);
        const wav = audioBufferToWav(rendered);
        const url = URL.createObjectURL(wav);
        const a = document.createElement('a');
        a.href = url;

        // 🔹 Get BPM value and sanitize name
        const bpm = parseFloat(bpmEl.value || '120');
        const bpmStr = isFinite(bpm) ? `${Math.round(bpm)}bpm` : 'bpm';
        const presetName = presets[i].name.replace(/[^a-z0-9_-]+/ig, '_');

        // 🔹 Include BPM in filename
        a.download = `${presetName}_${bpmStr}.wav`;

        a.click();
        globalStatus.textContent = `${presets[i].name} downloaded at ${bpmStr}`;
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    function audioBufferToWav(buffer) { const numCh = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const length = buffer.length; const bps = 2; const blockAlign = numCh * bps; const byteRate = sampleRate * blockAlign; const dataSize = length * blockAlign; const total = 44 + dataSize; const ab = new ArrayBuffer(total); const dv = new DataView(ab); let p = 0; function w8(v) { dv.setUint8(p++, v); } function w16(v) { dv.setUint16(p, v, true); p += 2; } function w32(v) { dv.setUint32(p, v, true); p += 4; } w8(0x52); w8(0x49); w8(0x46); w8(0x46); w32(36 + dataSize); w8(0x57); w8(0x41); w8(0x56); w8(0x45); w8(0x66); w8(0x6d); w8(0x74); w8(0x20); w32(16); w16(1); w16(numCh); w32(sampleRate); w32(byteRate); w16(blockAlign); w16(16); w8(0x64); w8(0x61); w8(0x74); w8(0x61); w32(dataSize); const chans = []; for (let ch = 0; ch < numCh; ch++) chans.push(buffer.getChannelData(ch)); for (let i = 0; i < length; i++) { for (let ch = 0; ch < numCh; ch++) { let s = Math.max(-1, Math.min(1, chans[ch][i])); s = s < 0 ? s * 0x8000 : s * 0x7fff; dv.setInt16(p, s, true); p += 2; } } return new Blob([ab], { type: 'audio/wav' }); }

    function startPlayhead(where, duration, canvas = null, miniIdx = -1, onEnd = null) {
      playhead.active = true; playhead.startAt = audioCtx.currentTime; playhead.duration = duration; playhead.where = where; playhead.canvas = canvas; playhead.miniIdx = miniIdx; if (rafId) cancelAnimationFrame(rafId);
      const tick = () => {
        const t = audioCtx.currentTime - playhead.startAt; if (t >= duration) { stopPlayhead(); onEnd && onEnd(); return; } if (where === 'main') drawMainWave(); else if (where === 'pre') drawPreWave(); else if (where === 'mini' && canvas) {
          const buf = presetBuffers[miniIdx];
          if (buf) {
            const beats = parseInt(presets[miniIdx].duration, 10) || 1;
            drawMiniFromBuffer(canvas, buf, t / duration, beats);
          }
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function stopPlayhead() {
      playhead.active = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      if (presetSrc) {
        presetSrc.stop();
        presetSrc = null;
      }

      if (playhead.where === 'main') drawMainWave();
      if (playhead.where === 'pre') drawPreWave();
      if (playhead.where === 'mini' && playhead.canvas) {
        const buf = presetBuffers[playhead.miniIdx];
        const beats = presetBeats[playhead.miniIdx] || 1;
        if (buf) drawMiniFromBuffer(playhead.canvas, buf, null, beats);
      }
      playhead.where = 'none';
    }

    function init() { fitCanvasToDisplay(preCanvas); fitCanvasToDisplay(waveCanvas); drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(); recControls.classList.add('idle'); setPreBtnState('play'); }
    init();

    generateBtn.addEventListener('click', async () => {
      if (!sampleBuffer) {
        recStatus.textContent = "No sample loaded.";
        return;
      }
      if ((clipEnd - clipStart) <= 0) {
        recStatus.textContent = "No audio selected for scratching.";
        return;
      }

      lastGeneratedWithSlip = slipModeEl.checked;
      presetBuffers = [];

      // eerst echt renderen (met noise/slip/random)
      for (let i = 0; i < presets.length; i++) {
        try {
          const rendered = await renderEffectToBuffer(presets[i]);
          presetBuffers[i] = rendered;
          presetBeats[i] = parseInt(presets[i].duration, 10) || 1;
        } catch (err) {
          presetBuffers[i] = null;
          console.error("Preset render failed:", err);
        }
      }

      // pas hier UI tekenen met exacte buffers
      renderPresetGrid();

      // previews tekenen op basis van de echte buffers
      presetGrid.querySelectorAll('.preset-card').forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (presetBuffers[idx]) {
          const beats = presetBeats[idx] || 1;
          drawMiniFromBuffer(mini, presetBuffers[idx], null, beats);
        }
      });

      // enable animaties
      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-card').forEach((card, idx) => {
          setTimeout(() => {
            card.classList.add('enabled');
            const actions = card.querySelector('.preset-actions');
            if (actions) actions.classList.add('enabled');
          }, idx * 100);
        });
      });

      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-card').forEach((el, idx) => {
          setTimeout(() => el.classList.add('enabled'), idx * 100);
        });
      });
    });


    const bubbleContainer = document.getElementById("bubbleContainer");

    function createBubble() {
      const bubble = document.createElement("span");
      bubble.classList.add("bubble");

      // Willekeurige grootte tussen 15 en 100 px
      const size = Math.floor(Math.random() * 60) + 15;
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;

      // Willekeurige horizontale positie
      const left = Math.random() * 100;
      bubble.style.left = `${left}%`;

      // Willekeurige duur van animatie (tussen 8 en 15 sec)
      const duration = Math.random() * 7 + 8;
      bubble.style.animationDuration = `${duration}s`;

      // Voeg toe aan DOM
      bubbleContainer.appendChild(bubble);

      // Verwijder bubble uit DOM na animatie om geheugen te sparen
      setTimeout(() => {
        bubble.remove();
      }, duration * 1000);
    }

    function animatePresetReload(card) {
      if (!card) return;
      // temporarily disable & fade out
      card.classList.remove('enabled');
      const actions = card.querySelector('.preset-actions');
      if (actions) actions.classList.remove('enabled');
      card.style.pointerEvents = 'none';

      // fade-out animation (already in CSS transition)
      setTimeout(() => {
        // re-enable visually after delay
        card.classList.add('enabled');
        if (actions) actions.classList.add('enabled');
        card.style.pointerEvents = 'auto';
      }, 150); // matches the .6s CSS transition duration
    }


    function updateTouchAction() {
      const preCanvas = document.getElementById('preCanvas');
      const waveCanvas = document.getElementById('waveCanvas');

      if (sampleBuffer) {
        preCanvas.style.touchAction = 'none';
        waveCanvas.style.touchAction = 'none';
      } else {
        preCanvas.style.touchAction = 'auto';
        waveCanvas.style.touchAction = 'auto';
      }
    }

    function humanizeScratchCurve(curve) {
      const len = curve.length;
      if (len < 2) return curve;

      const warped = new Float32Array(len);

      // === PARAMETERS ===
      const ampDepth = 0.02 + Math.random() * 0.015;   // amplitude variation
      const ampFreq = 1 + Math.random();               // amplitude speed
      const ampPhase = Math.random() * Math.PI * 2;

      const timeWarpDepth = 0.015;                     // timing variation
      const timeWarpFreq = 0.3 + Math.random() * 0.6;   // slower, 0.3–0.9 Hz
      const timeWarpPhase = Math.random() * Math.PI * 2;

      // Precompute warped time base
      const warpedT = new Float32Array(len);
      for (let i = 0; i < len; i++) {
        const t = i / (len - 1);
        warpedT[i] = t + timeWarpDepth * Math.sin(2 * Math.PI * timeWarpFreq * t + timeWarpPhase);
      }

      // Normalize time base (so it still starts at 0 and ends at 1)
      const minT = warpedT[0];
      const maxT = warpedT[len - 1];
      for (let i = 0; i < len; i++) {
        warpedT[i] = (warpedT[i] - minT) / (maxT - minT);
      }

      // Resample original curve onto warped time base
      for (let i = 0; i < len; i++) {
        const t = warpedT[i];
        const idx = t * (len - 1);
        const i0 = Math.floor(idx);
        const i1 = Math.min(len - 1, i0 + 1);
        const frac = idx - i0;
        const base = curve[i0] + (curve[i1] - curve[i0]) * frac;

        // Apply gentle amplitude modulation
        const ampFactor = 1 + ampDepth * Math.sin(2 * Math.PI * ampFreq * t + ampPhase);
        warped[i] = base * ampFactor;
      }

      // Ensure first and last values are preserved exactly
      warped[0] = curve[0];
      warped[len - 1] = curve[len - 1];

      return warped;
    }


    // Elke 2 seconden een bubble maken
    setInterval(createBubble, 2000);

    document.addEventListener('click', () => {
      document.querySelectorAll('.beat-popup').forEach(p => p.style.display = 'none');
    });

    loadNoiseBuffers();
    loadPresets();
  </script>
</body>

</html>