<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sample Scratcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e0e;
      --panel: #1e211f5c;
      --panel-elev: #222523;
      --line: #2a2a2a;
      --text: #f1f1f1;
      --muted: #a7a7a7;
      --muted-2: #8b8b8b;
      --accent: #1a9d4a;
      --accent-hover: #22c55e;
      --green: #22c55e;
      --danger: #ef4444;
      --white: #ffffff;
      --shadow: 0 10px 30px rgba(0, 0, 0, .3);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
    height: 100%;
      margin: 0;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(to bottom, #181C1A 0%, #0D0D0D 100%);
      background-attachment: fixed; 
      background-repeat: no-repeat;
      background-size: 100% 100%;

    }

    header {
      padding: 18px 22px;
      border-bottom: 1px solid var(--line);
      background: #0b0b0b;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: .5px;
      font-family: Oswald, sans-serif;
      font-weight: 700;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding-right: 20px;
      padding-bottom: 20px;
      padding-left: 20px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      overflow: hidden;
      z-index: 2
    }

    .panel.elev {
      background: var(--panel-elev);
      box-shadow: var(--shadow);
      border-color: #262626;
      z-index: 3
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title h2 {
      margin: 10px;
      font-size: 22px;
      font-family: Oswald, sans-serif;
      font-weight: 600;
      letter-spacing: .3px;
    }

    .section-sub {
      margin: -6px 0 8px;
      color: var(--muted-2);
      font-size: 14px;
    }

    .dropzone {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 260px;
      border: 2px dashed var(--line);
      border-radius: 18px;
      background: #121212;
      cursor: pointer;
      transition: transform .18s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }

    .dropzone:hover {
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, .25);
    }

    .dropzone.hover {
      border-color: var(--accent);
      background: #0f1511;
    }

    .dz-inner {
      text-align: center;
      line-height: 1.6;
    }

    .big-plus {
      font-size: 60px;
      font-weight: 700;
      font-family: Oswald, sans-serif;
      display: block;
    }

    .dz-title {
      font-size: 18px;
      font-weight: 600;
    }

    .dz-browse {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: underline;
    }

    .dz-browse:hover {
      color: var(--accent-hover);
    }

    input[type="file"] {
      display: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button,
    input,
    select {
      font-size: 16px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #0a0a0a;
      color: var(--text);
      transition: transform .12s ease, background .18s ease, box-shadow .18s ease, border-color .18s ease;
    }

    button {
      cursor: pointer;
    }

    button:hover {
      transform: translateY(-1px);
    }

    .primary {
      background: var(--accent);
      color: #000;
      border-color: transparent;
    }

    .primary:hover {
      background: var(--accent-hover);
    }

    .ghost {
      background: #141414;
    }

    .round-icon {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      border: 1px solid var(--line);
      background: linear-gradient(#121212, #0e0e0e);
      margin: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .25), inset 0 1px 0 rgba(255, 255, 255, .05);
    }

    .round-icon:active {
      transform: scale(.96);
    }

    .record-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 6px rgba(239, 68, 68, .12);
    }

    .stop-square {
      width: 18px;
      height: 18px;
      background: var(--white);
      box-shadow: 0 0 0 6px rgba(255, 255, 255, .1);
    }

    .rec-controls-wrap {
      display: grid;
      place-items: center;
      padding: 10px 0 2px;
    }

    .rec-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      background: #101010;
      border: 1px solid #242424;
      border-radius: 999px;
      padding: 8px 14px;
      box-shadow: var(--shadow);
    }

    .rec-status {
      text-align: center;
      color: var(--muted);
      margin-top: 6px;
      min-height: 18px;
    }

    /* Bubbles overlay website */
    .screen-overlay-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      top: 0;
      left: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 1;
    }

    .bubble {
      position: absolute;
      bottom: -100px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      animation: rise linear forwards;
    }

    @keyframes rise {
      to {
        transform: translateY(-110vh);
        opacity: 0;
      }
    }

    canvas {
      width: 100%;
      background: #121212;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 160px;
      touch-action: none;
      pointer-events: none;
    }

    /* Preselection – smaller, subtle */
    #preCanvas {
      height: 80px;
      background: #121212;
      cursor: crosshair;
    }

    .handles {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .handles .center {
      text-align: center;
      color: var(--muted);
      /* keep label dim */
    }

    .handles .center .value {
      color: #d7d7d7;
      /* pop just the number */
      font-weight: 600;
    }

    .tiny {
      font-size: 13px;
      padding: 6px 10px;
    }

    .pill {
      border-radius: 999px;
      padding: 8px 12px;
    }

    /* Settings controls */
    .settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      column-gap: 20px;
      gap: 14px;
    }

    .field label {
      font-size: 13px;
      color: var(--muted);
      display: inline-block;
    }

    /* Green themed slider */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 280px;
      height: 6px;
      border-radius: 999px;
      background: #2a2a2a;
      outline: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0e0e0e;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
      transition: transform .12s ease, background .18s ease;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent-hover);
      transform: scale(1.06);
    }

    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
    }

    input[type=range]::-moz-range-track {
      background: #2a2a2a;
      height: 6px;
      border-radius: 999px;
    }

    .status {
      min-height: 20px;
      color: var(--muted);
    }

    /* Effects grid */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 14px;
      justify-content: center;
      /* center last card if only one */
    }

    .preset-card {
      background: #2225234A;
      /* semi-transparent initial background */
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      padding: 14px;
      display: grid;
      gap: 14px;
      box-shadow: var(--shadow);
      transition: background 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled {
      background: #222523a1;
      /* solid background after fade-in */
    }

    .preset-card h3 {
      margin: 0;
      font-size: 20px;
      font-family: Oswald, sans-serif;
    }

    .mini-wrap {
      border-radius: 10px;
      overflow: hidden;
      background: #121212;
    }

    .mini-wave {
      width: 100%;
      height: 60px;
      background: #121212;
      display: block;
    }

    .curve-vis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .curve {
      position: relative;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      background: #121212;
      padding: 8px;
    }

    .curve h4 {
      position: absolute;
      top: 6px;
      left: 10px;
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, .5);
      font-weight: 600;
    }

    .curve canvas {
      width: 100%;
      height: 100px;
      border: none;
      background: transparent;
    }

    .preset-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .preset-actions .primary,
    .preset-actions .btn-ghost {
      width: 100%;
    }

    .preset-card .pname,
    .preset-card .meta b,
    .preset-card .duration {
      display: flex;
      align-items: center;
      opacity: 0.4;
      color: var(--muted);
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .pname,
    .preset-card.enabled .meta b,
    .preset-card.enabled .duration {
      opacity: 1;
      color: #fff;
    }

    .beat-icon {
      display: flex;
      align-items: center;
    }

    .beat-icon img.beat-svg {
      width: 30px;
      opacity: 0.2;
      transition: opacity 0.6s ease;
    }

    .beat-options {
  position: absolute;
  top: -9999px;
  left: -9999px;
  opacity: 0;
  transform: scale(0.8);
  transition: opacity 0.2s, transform 0.2s;
}

    .beat-popup {
  display: none;
  position: absolute;
  bottom: 40px;
  left: 0;
  right: 0;
  background: #111;
  border: 1px solid #2a2a2a;
  border-radius: 999px;
  padding: 6px 10px;
  display: flex;
  justify-content: center;
  gap: 8px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
  animation: fadeInUp .25s ease forwards;
  z-index: 5;
}

.beat-popup button {
  background: #222;
  border: 1px solid #444;
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 13px;
  color: #fff;
  cursor: pointer;
}
.beat-popup button:hover {
  background: var(--accent);
  color: #000;
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to   { opacity: 1; transform: translateY(0); }
}

    .preset-card.enabled .beat-icon img.beat-svg {
      opacity: 1;
    }

    .preset-card .beat-count {
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.5px;
      opacity: 0.4;
      color: #4d4d4d;
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .beat-count {
      opacity: 0.8;
      color: #8b8b8b;
    }

    .preset-card .meta {
      opacity: 0.4;
      color: #4d4d4d;
      transition: color 0.6s ease, opacity 0.6s ease;
    }

    .preset-card.enabled .meta {
      opacity: 1;
      color: #8b8b8b;
    }

    .preset-card canvas {
      opacity: 0.3;
      transition: opacity 0.6s ease;
    }

    .playBtn.playing {
      background: rgb(16, 102, 47);
      /* donkerder groen */
      border-color: transparent;
    }

    .preset-card.enabled canvas {
      opacity: 1;
    }

    .btn-ghost {
      background: #141414;
      border: 1px solid #2a2a2a;
      color: var(--text);
    }

    .meta {
      display: flex;
      align-items: center;
      gap: 5px;
      color: #6f6f6f;
      font-size: 13px;
    }

    .meta b {
      color: #cfcfcf;
      font-weight: 700;
    }

    /* Pulse animatie voor record */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }

      50% {
        box-shadow: 0 0 0 12px rgba(239, 68, 68, .6);
      }

      100% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }
    }

    /* State classes */
    .recording .record-dot {
      background: var(--danger);
      animation: pulse 1.2s infinite;
    }

    .recording .stop-square {
      background: var(--white);
      opacity: 1;
    }

    .idle .stop-square {
      background: var(--white);
      opacity: 0.3;
    }

    .idle .record-dot {
      background: var(--danger);
      animation: none;
    }

    .round-icon.small {
      width: 44px;
      height: 44px;
      margin: 4px;
    }

    /* Icon wrappers centreren */
    .round-icon.small .icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Play driehoekje */
    .icon-play {
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-left: 14px solid var(--white);
    }

    .icon-stop {
      width: 14px;
      height: 14px;
      background: var(--white);
    }

    /* Pause icon */
    .icon-pause {
      display: flex;
      gap: 4px;
    }

    .icon-pause span {
      display: block;
      width: 4px;
      height: 14px;
      background: var(--white);
    }

    .preset-actions button {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    /* Enabled state after generate */
    .preset-actions.enabled button {
      opacity: 1;
      cursor: pointer;
      pointer-events: auto;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }


    /* === Slip Mode Switch === */
    .switch-field {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .switch-label {
      height: 40px;
      font-size: 16px;
      font-family: Oswald, sans-serif;
      letter-spacing: .3px;
    }

    /* Switch styling */
    .switch {
      height: 40px;
      position: relative;
      display: inline-block;
      width: 50px;
      height: 28px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #333;
      transition: .3s;
      border-radius: 999px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      border-radius: 50%;
      transition: .3s;
    }

    /* Active state */
    .switch input:checked+.slider {
      background-color: var(--accent);
    }

    .switch input:checked+.slider:before {
      transform: translateX(22px);
    }

    /* Settings panel (no shadow, flat bottom) */
    #settingsPanel {
      margin-bottom: -15px;
      /* overlap into Effects */
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      box-shadow: none;
      /* remove its own shadow */
      position: relative;
      z-index: 2;
      /* ensure it’s above the page bg */
    }

    /* Effects panel (has shadow, flat top, casts shadow over Settings) */
    #effectsPanel {
      margin-top: 0;
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      box-shadow: var(--shadow);
      /* keep the drop shadow */
      position: relative;
      z-index: 2;
      /* sits above Settings, casts shadow */
    }


    /* Load Panel */
    #loadPanel {
      margin-bottom: -15px;
      /* pull it closer to Pre panel */
      border-bottom-left-radius: 0;
      /* flatten bottom corners */
      border-bottom-right-radius: 0;
      position: relative;
      z-index: 2;
      /* keep it above Pre panel */
    }

    /* Preselection Panel */
    #prePanel {
      margin-top: 0;
      border-top-left-radius: 0;
      /* flatten top corners */
      border-top-right-radius: 0;
    }

    .logo-container {
      text-align: center;
      /* Logo horizontaal centreren */
      padding: 30px 0;
      /* Boven- en onderruimte, pas aan naar wens */
    }

    .logo-container svg {
      width: 80px;
      /* Startwaarde voor grootte (pas aan) */
      height: auto;
      /* Aspect ratio behouden */
    }

    @media (max-width: 600px) {
      #generateBtn {
        display: block;
      }
    }

    @media (max-width: 600px) {
      .section-title {
        display: flex;
        align-items: initial;
      }
    }

    @media (max-width: 600px) {
      #prePanel.panel .section-title {
        display: block;
      }
    }

    footer {
      text-align: center;
      font-size: 14px;
      color: var(--muted);
      padding: 30px 10px;
      border-top: 1px solid var(--line);
      margin-top: 40px;
    }

    footer a {
      color: var(--muted);
      /* same gray tone as the footer text */
      text-decoration: none;
      /* remove underline */
    }

    footer a:hover {
      color: var(--accent);
      /* green accent on hover */
      text-decoration: underline;
      /* optional: subtle underline */
    }
  </style>
</head>

<body>

  <div class="logo-container">
    <a href="https://carpaudio.com/" aria-label="CARP Audio home">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1548.98 776.84" fill="white" role="img">
        <path
          d="M1434.66 250.53c49.4 7.08 89.34 14.69 114.32 19.74-32.34 25.12-64.8 46.08-96.78 63.64-342.5 187.99-745.43 48.19-898.88-14.58-8.9 3.34-22.27 8.38-38.45 14.58-102.56 39.38-166.33 67.73-204.17 83.52-110.91 46.31-260.83 108.91-287.69 72.92-6.65-8.91-7.73-26.51 13.63-64.4 18.99-33.68 44.45-63.27 74.5-87.6 59.83-48.44 113.16-66.41 153.16-73.39 56.49-9.84 65.07 5.97 250.57 9.28 57.53 1.03 96.97.21 141.86-3.98 64.22-5.98 110.93-16.17 127.92-19.74-17-3.57-63.7-13.75-127.92-19.74-44.89-4.19-84.33-5.01-141.86-3.98-185.5 3.31-194.08 19.13-250.57 9.28-40-6.97-93.34-24.95-153.18-73.4-30.05-24.33-55.51-53.91-74.49-87.59C15.27 37.2 16.35 19.6 23 10.69 49.86-25.29 199.78 37.3 310.69 83.61c37.84 15.8 101.61 44.15 204.17 83.52 16.17 6.22 29.55 11.26 38.45 14.58 153.45-62.78 556.37-202.58 898.88-14.58 31.98 17.55 64.45 38.53 96.78 63.64-24.97 5.07-64.91 12.68-114.31 19.76M159.95 726.82c1.63 0 2.87.57 3.74 1.72l12.65 18.54c.38.48.57 1.1.57 1.87 0 .96-.27 1.89-.79 2.8-.53.91-1.27 1.7-2.23 2.37-8.24 6.9-18.2 12.36-29.89 16.38s-23.09 6.04-34.2 6.04c-20.03 0-38.44-4.84-55.26-14.51-16.81-9.68-30.11-22.8-39.88-39.38C4.89 706.08 0 687.87 0 668.04s4.89-38.2 14.66-54.83c9.77-16.62 23.07-29.77 39.88-39.45s35.23-14.51 55.26-14.51c10.63 0 21.82 2.06 33.56 6.18 11.73 4.12 22.11 9.58 31.11 16.38 1.92 1.53 2.87 3.16 2.87 4.89 0 .86-.24 1.63-.72 2.3l-12.93 18.25c-.77 1.25-1.96 1.87-3.59 1.87-1.44 0-2.87-.58-4.31-1.72-7-5.17-14.54-9.27-22.63-12.29-8.1-3.02-15.88-4.53-23.35-4.53-14.18 0-27.16 3.45-38.95 10.35-11.78 6.9-21.13 16.26-28.02 28.1-6.9 11.83-10.35 24.84-10.35 39.02s3.45 27.02 10.35 38.8 16.26 21.1 28.1 27.95c11.83 6.85 24.79 10.28 38.87 10.28 7.47 0 15.26-1.48 23.35-4.46 8.09-2.97 15.5-7.04 22.2-12.22 1.52-1.05 3.05-1.58 4.59-1.58M390.17 769.08c0 1.25-.41 2.21-1.22 2.87-.82.67-1.99 1.01-3.52 1.01h-24.14c-1.34 0-2.56-.43-3.67-1.29q-1.65-1.29-2.37-3.45l-15.66-41.1h-92.55l-15.52 40.96q-.72 2.16-2.52 3.45t-3.81 1.29h-24c-3.07 0-4.6-1.2-4.6-3.59 0-.86.19-1.72.57-2.59l80.77-199.18c.57-1.53 1.46-2.73 2.66-3.59s2.51-1.29 3.95-1.29h17.82c1.44 0 2.75.46 3.95 1.37s2.03 2.08 2.52 3.52l80.77 199.18c.38 1.13.57 1.95.57 2.43m-61.07-69.7-35.78-94.13-35.78 94.13zM566.08 768.79c0 1.15-.38 2.11-1.15 2.87-.77.77-1.77 1.15-3.02 1.15h-26.3c-1.34 0-2.47-.33-3.38-1.01-.91-.67-1.85-1.82-2.8-3.45l-34.92-66.25h-42.68v65.25c0 1.72-.46 3.07-1.37 4.02-.91.96-2.23 1.44-3.95 1.44h-21.7c-3.45 0-5.17-1.82-5.17-5.46V568.17c0-1.63.48-2.95 1.44-3.95.96-1.01 2.2-1.51 3.74-1.51h67.25c13.99 0 26.49 2.92 37.51 8.77 11.02 5.84 19.59 14.08 25.72 24.72 6.13 10.63 9.2 22.8 9.2 36.5s-3.33 26.66-9.99 37.44-15.83 18.95-27.52 24.5l38.51 72c.38.66.58 1.38.58 2.15m-114.25-97.44h40.24c7.66 0 14.54-1.67 20.62-5.03 6.08-3.35 10.83-7.95 14.23-13.8q5.1-8.76 5.1-19.83c0-11.07-1.7-14.32-5.1-20.26s-8.14-10.58-14.23-13.94c-6.09-3.35-12.96-5.03-20.62-5.03h-40.24zM710.29 571.47q16.455 8.76 25.65 24.72c6.13 10.63 9.2 22.85 9.2 36.65s-3.07 25.68-9.2 36.22-14.68 18.71-25.65 24.5c-10.97 5.8-23.5 8.69-37.58 8.69h-37.94v65.1c0 1.72-.46 3.07-1.37 4.02-.91.96-2.23 1.44-3.95 1.44h-21.7c-3.45 0-5.17-1.82-5.17-5.46V568.17c0-1.63.48-2.95 1.44-3.95.96-1.01 2.2-1.51 3.74-1.51h64.96c14.08 0 26.6 2.92 37.57 8.76m-16.96 94.85c6.08-3.35 10.85-7.95 14.3-13.8 3.45-5.84 5.17-12.45 5.17-19.83s-1.7-14.18-5.1-20.12-8.17-10.59-14.3-13.94-13.03-5.03-20.69-5.03h-37.94v77.75h37.94c7.67 0 14.54-1.67 20.62-5.03M1016.18 769.08c0 1.25-.41 2.21-1.22 2.87-.81.67-1.99 1.01-3.52 1.01H987.3c-1.34 0-2.56-.43-3.67-1.29q-1.65-1.29-2.37-3.45l-15.67-41.1h-92.55l-15.52 40.96c-.48 1.44-1.32 2.59-2.51 3.45q-1.8 1.29-3.81 1.29h-24c-3.07 0-4.6-1.2-4.6-3.59 0-.86.19-1.72.58-2.59l80.77-199.18c.58-1.53 1.46-2.73 2.66-3.59s2.51-1.29 3.95-1.29h17.82c1.44 0 2.75.46 3.95 1.37s2.03 2.08 2.51 3.52l80.77 199.18c.38 1.13.57 1.95.57 2.43m-61.07-69.7-35.78-94.13-35.78 94.13zM1155.73 652.38v116.55c0 1.25-.36 2.23-1.08 2.95q-1.08 1.08-3.09 1.08h-18.4c-2.21 0-3.5-.91-3.88-2.73l-2.44-12.79c-4.6 6.04-10.33 10.78-17.17 14.23-6.85 3.45-14.21 5.17-22.06 5.17q-15.375 0-26.73-6.9c-7.57-4.6-13.37-11.16-17.39-19.69s-6.04-18.54-6.04-30.04v-67.69c0-1.34.38-2.37 1.15-3.09s1.77-1.08 3.02-1.08h22.99q2.01 0 3.09 1.08t1.08 3.09v67.98c0 4.89 1.22 9.34 3.67 13.37 2.44 4.02 5.75 7.21 9.92 9.56s8.69 3.52 13.58 3.52c5.17 0 9.94-1.22 14.3-3.66s7.83-5.84 10.42-10.2 3.88-9.27 3.88-14.73V652.4q0-4.17 4.02-4.17h23.14c2.67-.02 4.02 1.37 4.02 4.15M1312.88 563.64q1.08 1.08 1.08 3.09V768.5c0 1.34-.36 2.4-1.08 3.16-.72.77-1.75 1.15-3.09 1.15h-18.83c-.77 0-1.46-.22-2.08-.65s-1.03-.98-1.22-1.65l-2.59-16.81q-7.62 10.92-19.11 16.89c-7.67 3.97-16.1 5.96-25.29 5.96-11.31 0-21.51-2.87-30.61-8.62s-16.24-13.65-21.41-23.71-7.76-21.32-7.76-33.77 2.56-23.71 7.69-33.77c5.12-10.06 12.24-17.94 21.34-23.64s19.35-8.55 30.75-8.55c8.72 0 16.69 1.75 23.93 5.25 7.23 3.5 13.39 8.46 18.47 14.87l-.43-97.87c0-1.24.36-2.25 1.08-3.02s1.7-1.15 2.95-1.15h23.14c1.32 0 2.35.35 3.07 1.07m-48.15 177.92q8.265-4.815 13.08-13.08c4.815-8.265 4.81-11.57 4.81-18.18s-1.61-12.48-4.81-17.89c-3.21-5.41-7.59-9.7-13.15-12.86s-11.64-4.74-18.25-4.74-12.34 1.58-17.75 4.74-9.7 7.47-12.86 12.93-4.74 11.4-4.74 17.82 1.58 12.67 4.74 18.18 7.45 9.87 12.86 13.08 11.38 4.81 17.89 4.81 12.67-1.6 18.18-4.81M1354.77 607.83c-2.97-1.72-5.34-4.05-7.11-6.97s-2.66-6.11-2.66-9.56.88-6.66 2.66-9.63c1.77-2.97 4.14-5.32 7.11-7.04s6.18-2.59 9.63-2.59 6.66.86 9.63 2.59c2.97 1.72 5.32 4.07 7.04 7.04s2.59 6.18 2.59 9.63-.86 6.64-2.59 9.56c-1.72 2.92-4.07 5.25-7.04 6.97s-6.18 2.59-9.63 2.59-6.66-.86-9.63-2.59m24.07 41.25c.72.67 1.08 1.63 1.08 2.87v116.98c0 1.25-.36 2.21-1.08 2.87-.72.67-1.7 1.01-2.95 1.01h-23.28c-2.59 0-3.88-1.29-3.88-3.88V651.95c0-2.59 1.29-3.88 3.88-3.88h23.28c1.25 0 2.23.34 2.95 1.01M1413.91 677.32q8.985-15.165 24.36-24c15.375-8.835 21.51-8.84 33.77-8.84s23.38 2.95 33.63 8.84 18.35 13.89 24.29 24q8.91 15.165 8.91 33.27c0 18.105-3 23.14-8.98 33.2-5.99 10.06-14.08 18.04-24.29 23.93s-21.39 8.84-33.56 8.84-23.52-2.92-33.77-8.77c-10.25-5.84-18.37-13.82-24.36-23.93s-8.98-21.2-8.98-33.27c-.01-12.08 2.99-23.16 8.98-33.27M1441 728.4c3.16 5.46 7.47 9.8 12.93 13.01s11.45 4.81 17.96 4.81 12.53-1.6 18.04-4.81 9.84-7.52 13.01-12.93c3.16-5.41 4.74-11.38 4.74-17.89s-1.58-12.53-4.74-18.04-7.5-9.87-13.01-13.08-11.52-4.81-18.04-4.81-12.5 1.61-17.96 4.81q-8.19 4.815-12.93 13.08c-4.74 8.265-4.74 11.52-4.74 18.04-.01 6.41 1.57 12.35 4.74 17.81"
          class="carp-audio-logo-white_svg__cls-1"></path>
      </svg>
    </a>
  </div>

  <main>
    <!-- 1) Load Sample – full dropzone with centered refined recording controls -->
    <section class="panel elev" id="loadPanel">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drag and drop audio here or browse files">
        <div class="dz-inner">
          <span class="big-plus">+</span>
          <div class="dz-title">Drag & Drop Sample</div>
          <div><span class="dz-browse" id="browseLink">Or Browse Files</span></div>
          <input id="fileInput" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="rec-controls-wrap">
        <div class="rec-controls">
          <button id="recordBtn" class="round-icon" title="Record"><span class="record-dot"></span></button>
          <button id="stopBtn" class="round-icon" title="Stop" disabled><span class="stop-square"></span></button>
        </div>
        <div class="rec-status" id="recStatus">No sample loaded…</div>
      </div>
    </section>

    <section class="panel" id="prePanel">
      <div class="section-title">
        <h2 id="fileSubtitle"></h2>
        <div class="row" style="
    margin-bottom: 10px;
">
          <button id="reloadSampleBtn" class="tiny pill ghost" disabled>Reset</button>
          <button id="commitPreBtn" class="tiny pill primary" disabled>Cut Sample</button>
          <button id="prePlayBtn" class="round-icon small" title="Preview" disabled>
            <div class="icon icon-play"></div>
          </button>
        </div>
      </div>
      <canvas id="preCanvas" width="900" height="80"></canvas>
      <div class="handles">
        <span>Cut start: <span id="preStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="preLenLbl" class="value">0.00s</span></span>
        <span>Cut end: <span id="preEndLbl">0.00s</span></span>
      </div>
    </section>

    <!-- 3) Scratching Area -->
    <section class="panel">
      <div class="section-title">
        <h2>Scratch Area</h2>
      </div>
      <canvas id="waveCanvas" width="900" height="160" aria-label="Scratching waveform"></canvas>
      <div class="handles">
        <span>Start: <span id="clipStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="clipLenLbl" class="value">0.10s</span></span>
        <span>End: <span id="clipEndLbl">0.10s</span></span>
      </div>
    </section>

    <!-- 4) Settings -->
    <section class="panel" id="settingsPanel">
      <div class="section-title">
        <h2>Sample Generation</h2>
      </div>
      <div class="settings-row">
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">BPM</span>
          <input id="bpm" type="number" value="120" min="40" max="300" step="1" />
        </div>
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">Slip Mode</span>
          <label class="switch">
            <input id="slipMode" type="checkbox" />
            <span class="slider round"></span>
          </label>
        </div>
        <div class="field switch-field">
          <span style="padding:7px" class="switch-label">Vinyl Noise</span>
          <label class="switch">
            <input id="vinylNoise" type="checkbox" />
            <span class="slider round"></span>
          </label>
        </div>
        <button id="generateBtn" class="primary"
          style="font-size:20px; margin-left:auto; margin-right: 3px; padding:10px 90px 10px 90px; border-radius:999px; font-family: Oswald, sans-serif;"
          disabled>
          Generate Samples
        </button>
      </div>
    </section>

    <!-- 5) Effects -->
    <section class="panel" id="effectsPanel">
      <div id="presetGrid" class="preset-grid"></div>
    </section>
  </main>

  <template id="presetCardTpl">
    <div class="preset-card">
      <div class="section-title">
        <h3 class="pname"></h3>
        <span class="beat-icon"></span>
      </div>
      <div class="mini-wrap">
        <canvas class="mini-wave" width="300" height="54"></canvas>
      </div>
      <div class="meta">
        Duration: <span class="duration"></span>
      </div>
      <div class="preset-actions">
        <button class="playBtn primary">Play</button>
        <button class="dlBtn btn-ghost">Download</button>
      </div>
    </div>
  </template>

  <div class="screen-overlay-container">
    <div class="bubble-container" id="bubbleContainer"></div>
  </div>

  <footer>
    © 2025. <a href="https://carpaudio.com/" title="">CARP Audio</a>. All rights reserved.
  </footer>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let mediaRecorder, chunks = [];
    let sampleBuffer = null;
    let originalSampleBuffer = null;
    let sampleFileName = '';

    let preStart = 0, preEnd = 0;
    let clipStart = 0, clipEnd = 0.10;

    let rafId = null;
    let playhead = { active: false, startAt: 0, duration: 0, where: 'none', canvas: null, miniIdx: -1 };

    let mainSrc = null;

    let presetSrc = null;

    let presetBuffers = [];

    let presetBeats = [];

    let lastGeneratedWithSlip = false; // onthoud slip state bij Generate

    const slipModeEl = document.getElementById('slipMode');

    const recStatus = document.getElementById('recStatus');
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const browseLink = document.getElementById('browseLink');

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recControls = document.querySelector('.rec-controls');
    let recTimerInterval = null;
    let recStartTime = null;

    const fileSubtitle = document.getElementById('fileSubtitle');
    const preCanvas = document.getElementById('preCanvas');
    const preCtx = preCanvas.getContext('2d');
    const preStartLbl = document.getElementById('preStartLbl');
    const preEndLbl = document.getElementById('preEndLbl');
    const preLenLbl = document.getElementById('preLenLbl');
    const reloadSampleBtn = document.getElementById('reloadSampleBtn');
    const prePlayBtn = document.getElementById('prePlayBtn');
    const commitPreBtn = document.getElementById('commitPreBtn');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');
    const clipStartLbl = document.getElementById('clipStartLbl');
    const clipEndLbl = document.getElementById('clipEndLbl');
    const clipLenLbl = document.getElementById('clipLenLbl');

    const bpmEl = document.getElementById('bpm');
    const globalStatus = document.getElementById('globalStatus');

    const presetGrid = document.getElementById('presetGrid');
    const presetCardTpl = document.getElementById('presetCardTpl');

    const generateBtn = document.getElementById('generateBtn');

    // Vinyl Noise
    const vinylNoiseEl = document.getElementById('vinylNoise');
    const VINYL_NOISE_VOLUME = 0.20; // hardcoded: lager = subtieler

    let noiseBuffers = [];

    // ==== helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function sampleLinear(chData, pos) { const i = Math.floor(pos), f = pos - i; const i2 = Math.min(chData.length - 1, i + 1); return lerp(chData[i] || 0, chData[i2] || 0, f); }
    // Higher-quality interpolation (4-point cubic Hermite)
    function sampleCubic(chData, pos) {
      const i = Math.floor(pos);
      const frac = pos - i;

      const y0 = chData[i - 1] || 0;
      const y1 = chData[i] || 0;
      const y2 = chData[i + 1] || 0;
      const y3 = chData[i + 2] || 0;

      const a = (-0.5 * y0) + (1.5 * y1) - (1.5 * y2) + (0.5 * y3);
      const b = y0 - (2.5 * y1) + (2 * y2) - (0.5 * y3);
      const c = (-0.5 * y0) + (0.5 * y2);
      const d = y1;

      return a * frac * frac * frac + b * frac * frac + c * frac + d;
    }
    function secToX(sec, duration, width) { const ratio = duration ? (sec / duration) : 0; return Math.round(clamp(ratio, 0, 1) * (width - 1)); }
    function xToSec(x, duration, width) { const ratio = x / (width - 1); return ratio * (duration || 0); }

    function fitCanvasToDisplay(canvas) { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); const need = canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr); if (need) { canvas.width = Math.max(1, Math.round(rect.width * dpr)); canvas.height = Math.max(1, Math.round(rect.height * dpr)); } return dpr; }
    function canvasEventX(e, canvas) { const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect(); return clamp((e.clientX - r.left) * dpr, 0, canvas.width - 1); }

    function updateLabels() {
      clipStartLbl.textContent = (clipStart || 0).toFixed(2) + 's';
      clipEndLbl.textContent = (clipEnd || 0).toFixed(2) + 's';
      clipLenLbl.textContent = Math.max(0, (clipEnd - clipStart)).toFixed(2) + 's';
      preStartLbl.textContent = (preStart || 0).toFixed(2) + 's';
      preEndLbl.textContent = (preEnd || 0).toFixed(2) + 's';
      preLenLbl.textContent = Math.max(0, (preEnd - preStart)).toFixed(2) + 's';
    }

    // ==== drawing
    function drawPreWave() {
      const dpr = fitCanvasToDisplay(preCanvas);
      const Wp = preCanvas.width, Hp = preCanvas.height;
      preCtx.clearRect(0, 0, Wp, Hp);
      preCtx.fillStyle = '#121212';
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      preCtx.fillRect(0, 0, Wp, Hp);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wp));
      preCtx.strokeStyle = '#666';
      preCtx.lineWidth = Math.max(1, dpr);
      preCtx.beginPath();
      for (let x = 0; x < Wp; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * Hp;
        if (x === 0) preCtx.moveTo(x, y); else preCtx.lineTo(x, y);
      }
      preCtx.stroke();

      // Draw selection shading + handles
      const sX = secToX(preStart, sampleBuffer.duration, Wp);
      const eX = secToX(preEnd, sampleBuffer.duration, Wp);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      preCtx.fillStyle = 'rgba(34,197,94,0.18)';
      preCtx.fillRect(a, 0, Math.max(1, b - a), Hp);

      preCtx.strokeStyle = '#22c55e';
      preCtx.lineWidth = Math.max(2, 2 * dpr);
      preCtx.beginPath(); preCtx.moveTo(sX, 0); preCtx.lineTo(sX, Hp); preCtx.stroke();
      preCtx.beginPath(); preCtx.moveTo(eX, 0); preCtx.lineTo(eX, Hp); preCtx.stroke();

      // --- FIXED: playhead line ---
      if (playhead.active && playhead.where === 'pre') {
        const elapsed = audioCtx.currentTime - playhead.startAt;
        const rel = Math.min(elapsed, playhead.duration);   // clamp to selection length
        const x = secToX(preStart + rel, sampleBuffer.duration, Wp);
        preCtx.strokeStyle = '#ffffff';
        preCtx.lineWidth = Math.max(1, dpr);
        preCtx.beginPath();
        preCtx.moveTo(x, 0);
        preCtx.lineTo(x, Hp);
        preCtx.stroke();
      }
    }

    function drawMainWave() {
      const dpr = fitCanvasToDisplay(waveCanvas);
      const Wc = waveCanvas.width, Hc = waveCanvas.height;
      waveCtx.clearRect(0, 0, Wc, Hc);
      waveCtx.fillStyle = '#121212'; waveCtx.fillRect(0, 0, Wc, Hc);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wc));
      waveCtx.strokeStyle = '#16a34a';
      waveCtx.lineWidth = Math.max(1, dpr);
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      waveCtx.beginPath();
      for (let x = 0; x < Wc; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hc; if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y); }
      waveCtx.stroke();

      const sX = secToX(clipStart, sampleBuffer.duration, Wc), eX = secToX(clipEnd, sampleBuffer.duration, Wc);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)'; waveCtx.fillRect(a, 0, Math.max(1, b - a), Hc);

      waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = Math.max(2, 2 * dpr);
      waveCtx.beginPath(); waveCtx.moveTo(sX, 0); waveCtx.lineTo(sX, Hc); waveCtx.stroke();
      waveCtx.beginPath(); waveCtx.moveTo(eX, 0); waveCtx.lineTo(eX, Hc); waveCtx.stroke();

      // Play circle only (white mid bar removed for easier drag)
      const midX = Math.round((a + b) / 2);
      const r = 14 * dpr; const cy = Hc / 2;
      const isPlaying = playhead.active && playhead.where === 'main';
      waveCtx.beginPath(); waveCtx.arc(midX, cy, r, 0, Math.PI * 2); waveCtx.fillStyle = '#111'; waveCtx.fill(); waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = 2 * dpr; waveCtx.stroke();
      waveCtx.fillStyle = '#fff';
      if (!isPlaying) { const px = midX - 5 * dpr, py = cy - 7 * dpr; waveCtx.beginPath(); waveCtx.moveTo(px, py); waveCtx.lineTo(px, py + 14 * dpr); waveCtx.lineTo(px + 12 * dpr, cy); waveCtx.closePath(); waveCtx.fill(); }
      else {
        const size = 12 * dpr;
        waveCtx.fillRect(midX - size / 2, cy - size / 2, size, size);
      }

      if (playhead.active && playhead.where === 'main') {
        const p = clamp((audioCtx.currentTime - playhead.startAt) / playhead.duration, 0, 1);
        const x = a + p * (b - a);
        waveCtx.strokeStyle = '#ffffff'; waveCtx.lineWidth = Math.max(1, dpr);
        waveCtx.beginPath(); waveCtx.moveTo(x, 0); waveCtx.lineTo(x, Hc); waveCtx.stroke();
      }
    }

    function drawMiniFromBuffer(canvas, buffer, playPct = null, beats = 1) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212';
      ctx.fillRect(0, 0, w, h);
      if (!buffer) return;

      // waveform tekenen
      const data = buffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / w));
      ctx.strokeStyle = '#16a34a';
      ctx.lineWidth = Math.max(1, dpr);
      ctx.shadowColor = '#22c55e4A';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * h;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // beat-lijntjes tekenen (alleen als slip uit stond bij generate)
      if (!lastGeneratedWithSlip && beats > 1) {
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 0.5 * dpr;
        for (let b = 1; b < beats; b++) {
          const x = Math.round((b / beats) * w);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
      }

      // playhead tekenen
      if (playPct != null) {
        const x = clamp(Math.round(playPct * (w - 1)), 0, w - 1);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, dpr);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
    }


    function drawCurve(canvas, arr, lo, hi, label) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212'; ctx.fillRect(0, 0, w, h);
      if (!arr) return;
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let i = 0; i < w; i++) {
        const t = w > 1 ? i / (w - 1) : 0; const idx = Math.floor(t * (arr.length - 1));
        const v = arr[idx];
        const y = (1 - (v - lo) / (hi - lo)) * h;
        if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
      }
      ctx.stroke();
      // subtle label inside
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      ctx.font = `${12 * dpr}px system-ui, sans-serif`;
      const text = label || '';
      if (text) ctx.fillText(text, 10 * dpr, 18 * dpr);
    }

    async function loadNoiseBuffers() {
      const bufs = [];
      for (let i = 1; i <= 10; i++) {
        const url = `noise/noise${String(i).padStart(2, '0')}.wav`;
        const res = await fetch(url);
        const arr = await res.arrayBuffer();
        const buf = await audioCtx.decodeAudioData(arr);
        bufs.push(buf);
      }
      noiseBuffers = bufs;
      console.log("Loaded noise samples:", noiseBuffers.length);
    }

    function mixWithNoise(mainBuffer) {
      if (!vinylNoiseEl.checked || noiseBuffers.length === 0) return mainBuffer;

      // random noise sample
      const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
      const noiseOffset = Math.floor(Math.random() * noise.length);

      // nieuwe buffer voor mix
      const mixed = audioCtx.createBuffer(
        mainBuffer.numberOfChannels,
        mainBuffer.length,
        mainBuffer.sampleRate
      );

      for (let ch = 0; ch < mainBuffer.numberOfChannels; ch++) {
        const mainData = mainBuffer.getChannelData(ch);
        const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
        const mixedData = mixed.getChannelData(ch);

        for (let i = 0; i < mainBuffer.length; i++) {
          const n = noiseData[(i + noiseOffset) % noise.length]; // random start
          mixedData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
        }
      }
      return mixed;
    }

    // ==== load / record
    async function loadArrayBuffer(arr, name = '') {
      const decoded = await audioCtx.decodeAudioData(arr);

      const maxDuration = 60; // seconds – change if you want longer
      if (decoded.duration > maxDuration) {
        recStatus.textContent = `❌ File too long (${decoded.duration.toFixed(1)}s). Max allowed is ${maxDuration}s.`;
        return;
      }

      sampleBuffer = decoded;
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;

      // Default to 1s preselection
      preStart = 0;
      preEnd = Math.min(1, sampleBuffer.duration);

      // Default clip length (scratch area) – you can make it 1s too if you like
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      recStatus.textContent = `Sample: ${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate} Hz`;

      prePlayBtn.disabled = false;
      commitPreBtn.disabled = false;
      reloadSampleBtn.disabled = false;
      generateBtn.disabled = false;

      drawPreWave();
      drawMainWave();
      updateLabels();
    }

    dropzone.addEventListener('click', () => fileInput.click());
    browseLink.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
    dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', async (e) => { e.preventDefault(); dropzone.classList.remove('hover'); const file = e.dataTransfer.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); });
    fileInput.onchange = async (e) => { const file = e.target.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); };

    const startRecording = async () => {
      await audioCtx.resume();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => e.data && chunks.push(e.data);
      mediaRecorder.onstop = async () => { const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' }); const arr = await blob.arrayBuffer(); await loadArrayBuffer(arr, 'Recorded Sample'); };
      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;

      // Zet state class
      recControls.classList.remove('idle');
      recControls.classList.add('recording');

      // Start timer
      recStartTime = Date.now();
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = setInterval(() => {
        const elapsed = ((Date.now() - recStartTime) / 1000).toFixed(1);
        recStatus.textContent = `Recording… ${elapsed}s`;
      }, 200);
    };
    recordBtn.onclick = startRecording;
    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); stopBtn.disabled = true; recordBtn.disabled = false; // Reset state
      recControls.classList.remove('recording');
      recControls.classList.add('idle');

      // Stop timer
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = null;
      recStatus.textContent = 'Stopped. Processing sample…';
    };

    // ==== Preselection interactions
    let preDragging = null; // 'start' | 'end' | 'move' | 'new'
    const HANDLE_EPS = 12 * (window.devicePixelRatio || 1);

    function preHitTest(x) {
      const sX = secToX(preStart, sampleBuffer?.duration, preCanvas.width);
      const eX = secToX(preEnd, sampleBuffer?.duration, preCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updatePreCursor(e) { if (!sampleBuffer) { preCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, preCanvas); const kind = preHitTest(x); preCanvas.style.cursor = (kind === 'move') ? 'grab' : (kind === 'start' || kind === 'end') ? 'ew-resize' : 'crosshair'; }

    preCanvas.addEventListener('pointermove', (e) => {
      if (!preDragging) updatePreCursor(e);
      if (!sampleBuffer || !preDragging) return;
      const x = canvasEventX(e, preCanvas);
      const sec = xToSec(x, sampleBuffer.duration, preCanvas.width);
      if (preDragging === 'start') preStart = Math.min(sec, preEnd - 0.005);
      else if (preDragging === 'end') preEnd = Math.max(sec, preStart + 0.005);
      else if (preDragging === 'move') { const width = preEnd - preStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); preStart = ns; preEnd = ns + width; }
      else if (preDragging === 'new') { preEnd = Math.max(sec, 0); preStart = Math.min(sec, preStart); }
      drawPreWave(); updateLabels();
    });
    preCanvas.addEventListener('pointerdown', (e) => { if (!sampleBuffer) return; preCanvas.setPointerCapture(e.pointerId); const x = canvasEventX(e, preCanvas); const ht = preHitTest(x); if (ht === 'new') { const sec = xToSec(x, sampleBuffer.duration, preCanvas.width); preStart = sec; preEnd = sec; } preDragging = ht; updatePreCursor(e); });
    preCanvas.addEventListener('pointerup', (e) => { preDragging = null; preCanvas.releasePointerCapture(e.pointerId); updatePreCursor(e); });
    preCanvas.addEventListener('pointerleave', () => { preDragging = null; preCanvas.style.cursor = 'crosshair'; });

    let preSrc = null;

    function setPreBtnState(state) {
      prePlayBtn.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'icon';

      if (state === 'play') {
        const icon = document.createElement('div');
        icon.className = 'icon-play';
        wrapper.appendChild(icon);
      } else if (state === 'stop') {
        const icon = document.createElement('div');
        icon.className = 'icon-stop';
        wrapper.appendChild(icon);
      }

      prePlayBtn.appendChild(wrapper);
    }

    prePlayBtn.onclick = () => {
      if (!sampleBuffer) return;

      if (preSrc) {
        // already playing → stop
        preSrc.stop();
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
        return;
      }

      // create new buffer with selection
      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
      };

      src.start();
      preSrc = src;
      setPreBtnState('stop');
      startPlayhead('pre', (preEnd - preStart));
    };

    commitPreBtn.onclick = () => {
      if (!sampleBuffer) return;
      const chs = sampleBuffer.numberOfChannels; const sr = sampleBuffer.sampleRate; const len = Math.max(1, Math.floor((preEnd - preStart) * sr)); const newBuf = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) { const inData = sampleBuffer.getChannelData(ch); const outData = newBuf.getChannelData(ch); const startIdx = Math.floor(preStart * sr); for (let i = 0; i < len; i++) { outData[i] = inData[startIdx + i] || 0; } }
      sampleBuffer = newBuf; preStart = 0; preEnd = sampleBuffer.duration; clipStart = 0; clipEnd = Math.min(0.10, sampleBuffer.duration);
      drawPreWave(); drawMainWave(); updateLabels(); globalStatus.textContent = 'Preselection applied as new sample';
    };

    reloadSampleBtn.onclick = () => {
      if (!originalSampleBuffer) return;
      sampleBuffer = originalSampleBuffer;   // restore
      preStart = 0;
      preEnd = sampleBuffer.duration;
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      drawPreWave();
      drawMainWave();
      updateLabels();
      globalStatus.textContent = 'Sample reloaded to original state';
    };

    // ==== main selection with play circle (no visible mid bar)
    let dragging = null; // 'start' | 'end' | 'move'
    const MAIN_HANDLE_EPS = 14 * (window.devicePixelRatio || 1);

    function isInsidePlayCircle(x, y) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      const midX = (a + b) / 2;
      const cy = waveCanvas.height / 2;

      const dpr = (window.devicePixelRatio || 1);
      const r = 14 * dpr;

      // echte afstand check
      const dx = x - midX;
      const dy = y - cy;
      return dx * dx + dy * dy <= r * r;
    }

    function mainHitTest(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);

      if (Math.abs(x - sX) <= MAIN_HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= MAIN_HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updateMainCursor(e) {
      if (!sampleBuffer) {
        waveCanvas.style.cursor = 'not-allowed';
        return;
      }

      const x = canvasEventX(e, waveCanvas);
      const y = (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1);

      // Check playbutton eerst
      if (isInsidePlayCircle(x, y)) {
        waveCanvas.style.cursor = 'pointer';
        return;
      }

      const ht = mainHitTest(x);

      if (ht === 'move') {
        waveCanvas.style.cursor = 'grab';
      } else if (ht === 'start' || ht === 'end') {
        waveCanvas.style.cursor = 'ew-resize';
      } else if (ht === 'new') {
        waveCanvas.style.cursor = 'crosshair'; // vrij selecteren
      } else {
        waveCanvas.style.cursor = 'default';
      }
    }

    waveCanvas.addEventListener('pointerdown', (e) => {
      if (!sampleBuffer) return;
      waveCanvas.setPointerCapture(e.pointerId);
      const x = canvasEventX(e, waveCanvas);
      if (isInsidePlayCircle(x, (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1))) {
        if (playhead.active && playhead.where === 'main') {
          stopPlayhead();
        } else {
          playClipSelection();
        }
        return;
      }
      const ht = mainHitTest(x);
      if (ht === 'new') {
        const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
        clipStart = sec;
        clipEnd = sec;
      }
      dragging = ht;
    });
    waveCanvas.addEventListener('pointermove', (e) => {
      if (!dragging) updateMainCursor(e);
      if (!sampleBuffer || !dragging) return;
      const x = canvasEventX(e, waveCanvas);
      const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
      if (dragging === 'start') clipStart = Math.min(sec, clipEnd - 0.005);
      else if (dragging === 'end') clipEnd = Math.max(sec, clipStart + 0.005);
      else if (dragging === 'move') { const width = clipEnd - clipStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); clipStart = ns; clipEnd = ns + width; }
      else if (dragging === 'new') {
        clipEnd = Math.max(sec, 0);
        clipStart = Math.min(sec, clipStart);
      }
      drawMainWave(); updateLabels();
    });
    waveCanvas.addEventListener('pointerup', (e) => { dragging = null; waveCanvas.releasePointerCapture(e.pointerId); updateMainCursor(e); });
    waveCanvas.addEventListener('pointerleave', () => { dragging = null; waveCanvas.style.cursor = 'crosshair'; });

    function playClipSelection() {
      if (!sampleBuffer) return;

      // stop eventueel vorige afspeler
      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((clipEnd - clipStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(clipStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        mainSrc = null;
        stopPlayhead();
      };

      src.start();
      mainSrc = src;

      startPlayhead('main', (clipEnd - clipStart));
    }

    function curveFromFormula(formula, samples, lo, hi) {
      let fn; try { fn = new Function('t', `return (${formula});`); } catch (err) { throw new Error('Formula error: ' + err.message); }
      const arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) { const t = samples > 1 ? i / (samples - 1) : 0; let v; try { v = fn(t); } catch (e) { v = 0; } if (!Number.isFinite(v)) v = 0; arr[i] = clamp(v, lo, hi); }
      return arr;
    }

    async function renderEffectToBuffer(preset) {
      if (!sampleBuffer) throw new Error('No sample loaded or recorded.');

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
      const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: bouw scratchInput buffer (sample + noise als één bron) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];

        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );

        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);

          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length]; // loop de noise
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = new AudioBuffer({
        length: scratchSamples,
        numberOfChannels: scratchInput.numberOfChannels,
        sampleRate: sr
      });

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }

        if (scratchSamples > 0) {
          const v = sampleCubic(inData, lastPos);
          outData[scratchSamples - 1] = v * gainCurve[scratchSamples - 1];
        }

        // Fade in/out (anti-click)
        const fadeSamples = Math.floor(sr * 0.05);
        for (let i = 0; i < fadeSamples; i++) {
          const t = i / fadeSamples;
          outData[i] *= t;
          const j = outData.length - 1 - i;
          if (j >= 0) outData[j] *= t;
        }
      }

      // === Stap 3: Slip Mode continuation ===
      if (slipModeEl.checked) {
        const slipRemaining = Math.max(0, scratchInput.length - Math.floor(lastPos));
        const slipSamples = slipRemaining;

        const extended = new AudioBuffer({
          length: out.length + slipSamples,
          numberOfChannels: out.numberOfChannels,
          sampleRate: sr
        });

        // Copy scratch part
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Fill slip continuation
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);
          let pos = Math.floor(lastPos);
          for (let i = 0; i < slipSamples; i++) {
            extData[out.length + i] = inData[pos + i] || 0;
          }
        }

        out = extended;
      }

      // === Stap 4: render in OfflineAudioContext ===
      return out;
    }

    // ==== Presets
    let presets = [];

    async function loadPresets() {
      try {
        const res = await fetch("scratches.json");
        presets = await res.json();
        console.log("Scratch curves loaded:", presets);

        // Now initialize UI only after presets exist
        init();
      } catch (err) {
        console.error("Failed to load scratch curves:", err);
      }
    }

    function init() {
      fitCanvasToDisplay(preCanvas);
      fitCanvasToDisplay(waveCanvas);
      drawPreWave();
      drawMainWave();
      updateLabels();
      renderPresetGrid();   // <-- now this has data
      recControls.classList.add('idle');
      setPreBtnState('play');
    }

    async function renderPresetGrid() {
  presetGrid.innerHTML = '';

  // --- create ONE global popup and reuse it ---
  let options = document.querySelector('.beat-options');
  if (!options) {
    options = document.createElement('div');
    options.className = "beat-options";
    Object.assign(options.style, {
      position: "absolute",
      display: "flex",
      flexDirection: "row",
      justifyContent: "center",
      alignItems: "center",
      gap: "10px",
      padding: "6px 10px",
      background: "rgba(20,20,20,0.95)",
      border: "1px solid #333",
      borderRadius: "999px",
      boxShadow: "0 6px 20px rgba(0,0,0,0.5)",
      zIndex: "999999",
      opacity: "0",
      transform: "scale(0.8)",
      pointerEvents: "none",
      transition: "opacity 0.2s ease, transform 0.2s ease"
    });

    // add beat icons once
    [1, 2, 3, 4].forEach(optBeat => {
      const opt = document.createElement('img');
      opt.src = `icons/beat-${optBeat}.svg`;
      opt.alt = `${optBeat} beat`;
      opt.style.width = "28px";
      opt.style.cursor = "pointer";
      options.appendChild(opt);
    });

    document.body.appendChild(options);
  }

  presets.forEach((p, idx) => {
    const node = presetCardTpl.content.cloneNode(true);
    const card = node.querySelector('.preset-card');
    node.querySelector('.pname').textContent = p.name;

    const beats = parseInt(p.duration, 10) || 1;
    const currentBeat = presetBeats[idx] || beats;
    const beatIconWrap = node.querySelector('.beat-icon');

    // --- main beat icon ---
    beatIconWrap.innerHTML = `
      <img src="icons/beat-${currentBeat}.svg" alt="${currentBeat} beat" class="beat-svg">
    `;

    // make beat icon clickable
    beatIconWrap.style.position = "relative";
    beatIconWrap.style.cursor = "pointer";

    let activeBeatIcon = null; // track which card opened the popup

beatIconWrap.addEventListener("click", (e) => {
  e.stopPropagation();

  // if clicking the same icon again → close it
  if (activeBeatIcon === beatIconWrap) {
    options.style.opacity = "0";
    options.style.transform = "scale(0.8)";
    options.style.pointerEvents = "none";
    activeBeatIcon = null;
    return;
  }

  // otherwise open for this card
  activeBeatIcon = beatIconWrap;

  // position popup
  const rect = beatIconWrap.getBoundingClientRect();
  options.style.top = (window.scrollY + rect.top - options.offsetHeight - 8) + "px";
  options.style.left = (window.scrollX + rect.left + rect.width / 2 - options.offsetWidth / 2) + "px";

  // highlight correct beat
  const currentBeat = presetBeats[idx] || parseInt(p.duration, 10) || 1;
  options.querySelectorAll('img').forEach(img => {
    const optBeat = parseInt(img.alt, 10);
    if (optBeat === currentBeat) {
      img.style.opacity = "1";
      img.style.transform = "scale(1.1)";
    } else {
      img.style.opacity = "0.2";
      img.style.transform = "scale(1)";
    }
  });

  // show popup
  options.style.opacity = "1";
  options.style.transform = "scale(1)";
  options.style.pointerEvents = "auto";

      // attach click handlers dynamically
      options.querySelectorAll('img').forEach(opt => {
        opt.onclick = async (ev) => {
          ev.stopPropagation();
          const optBeat = parseInt(opt.alt, 10);

          presets[idx].duration = optBeat;

          try {
            const rendered = await renderEffectToBuffer(presets[idx]);
            presetBuffers[idx] = rendered;
            presetBeats[idx] = optBeat;
          } catch (err) {
            console.error("Re-render failed:", err);
          }

          // update duration + icon
          const durationEl = card.querySelector('.duration');
          if (presetBuffers[idx]) {
            durationEl.textContent = `${presetBuffers[idx].duration.toFixed(2)}s`;
          }
          const beatIconImg = card.querySelector('.beat-svg');
          beatIconImg.src = `icons/beat-${optBeat}.svg`;
          beatIconImg.alt = `${optBeat} beat`;

          const mini = card.querySelector('.mini-wave');
          if (presetBuffers[idx]) {
            drawMiniFromBuffer(mini, presetBuffers[idx], null, optBeat);
          }

          // close popup
          options.style.opacity = "0";
          options.style.transform = "scale(0.8)";
          options.style.pointerEvents = "none";
          activeBeatIcon = null;
        };
      });
    });

    // --- duration label ---
    if (presetBuffers[idx]) {
      node.querySelector('.duration').textContent =
        `${presetBuffers[idx].duration.toFixed(2)}s`;
    } else {
      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      node.querySelector('.duration').textContent =
        `${(beatDur * currentBeat).toFixed(2)}s`;
    }

    // --- mini waveform preview ---
    const mini = node.querySelector('.mini-wave');
    if (sampleBuffer) {
      const preview = synthesizePreviewBuffer(p);
      drawMiniFromBuffer(mini, preview, null, currentBeat);
    }

    // --- play / download handlers ---
    const playBtn = node.querySelector('.playBtn');
    const dlBtn = node.querySelector('.dlBtn');
    playBtn.addEventListener('click', async () => {
      await handlePlayPreset(idx, playBtn, mini);
    });
    dlBtn.addEventListener('click', async () => {
      await handleDownloadPreset(idx);
    });
    mini.addEventListener('click', async () => {
      await handlePlayPreset(idx, playBtn, mini);
    });

    presetGrid.appendChild(node);
  });

  // close popup when clicking outside
  document.addEventListener('click', (e) => {
  if (!e.target.closest('.beat-options') && !e.target.closest('.beat-icon')) {
    options.style.opacity = "0";
    options.style.transform = "scale(0.8)";
    options.style.pointerEvents = "none";
    activeBeatIcon = null;
  }
});
}


    function synthesizePreviewBuffer(preset) {
      if (!sampleBuffer) return null;

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
      const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: scratchInput bouwen (sample + noise) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );
        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);
          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length];
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = audioCtx.createBuffer(
        scratchInput.numberOfChannels,
        scratchSamples,
        sr
      );

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }
      }

      // === Stap 3: Slip Mode continuation (ook in preview!) ===
      if (slipModeEl.checked) {
        const slipRemaining = Math.max(0, scratchInput.length - Math.floor(lastPos));
        const slipSamples = slipRemaining;

        const extended = audioCtx.createBuffer(
          out.numberOfChannels,
          out.length + slipSamples,
          sr
        );

        // Copy scratch part
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Fill slip continuation
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);
          let pos = Math.floor(lastPos);
          for (let i = 0; i < slipSamples; i++) {
            extData[out.length + i] = inData[pos + i] || 0;
          }
        }

        out = extended;
      }

      return out;
    }

    async function updatePresetThumbnails() {

      // Then loop over all preset cards and draw mini-wave previews
      const cards = presetGrid.querySelectorAll('.preset-card');
      cards.forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (!mini) return;
        const preview = synthesizePreviewBuffer(presets[idx]);
        if (preview) {
          drawMiniFromBuffer(mini, preview, null);
        }
      });
    }

    async function handlePlayPreset(i, buttonEl, miniCanvas) {
      try {
        await audioCtx.resume();

        // stop if already playing
        if (presetSrc) {
          presetSrc.stop();
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
          return;
        }

        // use cached buffer
        const rendered = presetBuffers[i];
        if (!rendered) {
          globalStatus.textContent = "Preset not generated yet. Click Generate first!";
          return;
        }

        const src = audioCtx.createBufferSource();
        src.buffer = rendered;
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(12000, audioCtx.currentTime); // cutoff ~12kHz
        src.connect(filter).connect(audioCtx.destination);

        src.onended = () => {
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
        };

        src.start();
        presetSrc = src;

        buttonEl.textContent = 'Stop';
        buttonEl.classList.add('playing');
        startPlayhead('mini', rendered.duration, miniCanvas, i);
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    async function handleDownloadPreset(i) { try { const rendered = await renderEffectToBuffer(presets[i]); const wav = audioBufferToWav(rendered); const url = URL.createObjectURL(wav); const a = document.createElement('a'); a.href = url; a.download = `${presets[i].name.replace(/[^a-z0-9_-]+/ig, '_')}.wav`; a.click(); globalStatus.textContent = `${presets[i].name} downloaded`; } catch (err) { globalStatus.textContent = err.message; } }

    function audioBufferToWav(buffer) { const numCh = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const length = buffer.length; const bps = 2; const blockAlign = numCh * bps; const byteRate = sampleRate * blockAlign; const dataSize = length * blockAlign; const total = 44 + dataSize; const ab = new ArrayBuffer(total); const dv = new DataView(ab); let p = 0; function w8(v) { dv.setUint8(p++, v); } function w16(v) { dv.setUint16(p, v, true); p += 2; } function w32(v) { dv.setUint32(p, v, true); p += 4; } w8(0x52); w8(0x49); w8(0x46); w8(0x46); w32(36 + dataSize); w8(0x57); w8(0x41); w8(0x56); w8(0x45); w8(0x66); w8(0x6d); w8(0x74); w8(0x20); w32(16); w16(1); w16(numCh); w32(sampleRate); w32(byteRate); w16(blockAlign); w16(16); w8(0x64); w8(0x61); w8(0x74); w8(0x61); w32(dataSize); const chans = []; for (let ch = 0; ch < numCh; ch++) chans.push(buffer.getChannelData(ch)); for (let i = 0; i < length; i++) { for (let ch = 0; ch < numCh; ch++) { let s = Math.max(-1, Math.min(1, chans[ch][i])); s = s < 0 ? s * 0x8000 : s * 0x7fff; dv.setInt16(p, s, true); p += 2; } } return new Blob([ab], { type: 'audio/wav' }); }

    function startPlayhead(where, duration, canvas = null, miniIdx = -1, onEnd = null) {
      playhead.active = true; playhead.startAt = audioCtx.currentTime; playhead.duration = duration; playhead.where = where; playhead.canvas = canvas; playhead.miniIdx = miniIdx; if (rafId) cancelAnimationFrame(rafId);
      const tick = () => {
        const t = audioCtx.currentTime - playhead.startAt; if (t >= duration) { stopPlayhead(); onEnd && onEnd(); return; } if (where === 'main') drawMainWave(); else if (where === 'pre') drawPreWave(); else if (where === 'mini' && canvas) {
          const buf = presetBuffers[miniIdx];
          if (buf) {
            const beats = parseInt(presets[miniIdx].duration, 10) || 1;
            drawMiniFromBuffer(canvas, buf, t / duration, beats);
          }
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function stopPlayhead() {
      playhead.active = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      if (presetSrc) {
        presetSrc.stop();
        presetSrc = null;
      }

      if (playhead.where === 'main') drawMainWave();
      if (playhead.where === 'pre') drawPreWave();
      if (playhead.where === 'mini' && playhead.canvas) {
        const buf = presetBuffers[playhead.miniIdx];
        const beats = presetBeats[playhead.miniIdx] || 1;
        if (buf) drawMiniFromBuffer(playhead.canvas, buf, null, beats);
      }
      playhead.where = 'none';
    }

    function init() { fitCanvasToDisplay(preCanvas); fitCanvasToDisplay(waveCanvas); drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(); recControls.classList.add('idle'); setPreBtnState('play'); }
    init();

    generateBtn.addEventListener('click', async () => {
      lastGeneratedWithSlip = slipModeEl.checked; // onthoud slip state
      // reset buffers
      presetBuffers = [];

      // eerst echt renderen (met noise/slip/random)
      for (let i = 0; i < presets.length; i++) {
        try {
          const rendered = await renderEffectToBuffer(presets[i]);
          presetBuffers[i] = rendered;
          presetBeats[i] = parseInt(presets[i].duration, 10) || 1;
        } catch (err) {
          presetBuffers[i] = null;
          console.error("Preset render failed:", err);
        }
      }

      // pas hier UI tekenen met exacte buffers
      renderPresetGrid();

      // previews tekenen op basis van de echte buffers
      presetGrid.querySelectorAll('.preset-card').forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (presetBuffers[idx]) {
          const beats = presetBeats[idx] || 1;
          drawMiniFromBuffer(mini, presetBuffers[idx], null, beats);
        }
      });

      // enable animaties
      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-actions').forEach((el, idx) => {
          setTimeout(() => el.classList.add('enabled'), idx * 100);
        });
      });

      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-card').forEach((el, idx) => {
          setTimeout(() => el.classList.add('enabled'), idx * 100);
        });
      });
    });


    const bubbleContainer = document.getElementById("bubbleContainer");

    function createBubble() {
      const bubble = document.createElement("span");
      bubble.classList.add("bubble");

      // Willekeurige grootte tussen 15 en 100 px
      const size = Math.floor(Math.random() * 60) + 15;
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;

      // Willekeurige horizontale positie
      const left = Math.random() * 100;
      bubble.style.left = `${left}%`;

      // Willekeurige duur van animatie (tussen 8 en 15 sec)
      const duration = Math.random() * 7 + 8;
      bubble.style.animationDuration = `${duration}s`;

      // Voeg toe aan DOM
      bubbleContainer.appendChild(bubble);

      // Verwijder bubble uit DOM na animatie om geheugen te sparen
      setTimeout(() => {
        bubble.remove();
      }, duration * 1000);
    }

    // Elke 2 seconden een bubble maken
    setInterval(createBubble, 2000);

    document.addEventListener('click', () => {
  document.querySelectorAll('.beat-popup').forEach(p => p.style.display = 'none');
});

    loadNoiseBuffers();
    loadPresets();
  </script>
</body>

</html>