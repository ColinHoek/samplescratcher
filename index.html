<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sample Scratcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e0e;
      --panel: #171717;
      --panel-elev: #1d1d1d;
      --line: #2a2a2a;
      --text: #f1f1f1;
      --muted: #a7a7a7;
      --muted-2: #8b8b8b;
      --accent: #1a9d4a;
      --accent-hover: #22c55e;
      --green: #22c55e;
      --danger: #ef4444;
      --white: #ffffff;
      --shadow: 0 10px 30px rgba(0, 0, 0, .3);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: radial-gradient(1000px 700px at 10% -10%, #121212, #0b0b0b);
    }

    header {
      padding: 18px 22px;
      border-bottom: 1px solid var(--line);
      background: #0b0b0b;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: .5px;
      font-family: Oswald, sans-serif;
      font-weight: 700;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      overflow: hidden;
    }

    .panel.elev {
      background: var(--panel-elev);
      box-shadow: var(--shadow);
      border-color: #262626;
    }

    .section-title {
      margin: 0 0 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .section-title h2 {
      margin: 0;
      font-size: 22px;
      font-family: Oswald, sans-serif;
      font-weight: 600;
      letter-spacing: .3px;
    }

    .section-sub {
      margin: -6px 0 8px;
      color: var(--muted-2);
      font-size: 14px;
    }

    .dropzone {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 260px;
      border: 2px dashed var(--line);
      border-radius: 18px;
      background: #121212;
      cursor: pointer;
      transition: transform .18s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }

    .dropzone:hover {
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, .25);
    }

    .dropzone.hover {
      border-color: var(--accent);
      background: #0f1511;
    }

    .dz-inner {
      text-align: center;
      line-height: 1.6;
    }

    .big-plus {
      font-size: 60px;
      font-weight: 700;
      font-family: Oswald, sans-serif;
      display: block;
    }

    .dz-title {
      font-size: 18px;
      font-weight: 600;
    }

    .dz-browse {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: underline;
    }

    .dz-browse:hover {
      color: var(--accent-hover);
    }

    input[type="file"] {
      display: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button,
    input,
    select {
      font-size: 16px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #151515;
      color: var(--text);
      transition: transform .12s ease, background .18s ease, box-shadow .18s ease, border-color .18s ease;
    }

    button {
      cursor: pointer;
    }

    button:hover {
      transform: translateY(-1px);
    }

    .primary {
      background: var(--accent);
      color: #000;
      border-color: transparent;
    }

    .primary:hover {
      background: var(--accent-hover);
    }

    .ghost {
      background: #141414;
    }

    .round-icon {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      border: 1px solid var(--line);
      background: linear-gradient(#121212, #0e0e0e);
      margin: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .25), inset 0 1px 0 rgba(255, 255, 255, .05);
    }

    .round-icon:active {
      transform: scale(.96);
    }

    .record-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 6px rgba(239, 68, 68, .12);
    }

    .stop-square {
      width: 18px;
      height: 18px;
      background: var(--white);
      box-shadow: 0 0 0 6px rgba(255, 255, 255, .1);
    }

    .rec-controls-wrap {
      display: grid;
      place-items: center;
      padding: 10px 0 2px;
    }

    .rec-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      background: #101010;
      border: 1px solid #242424;
      border-radius: 999px;
      padding: 8px 14px;
      box-shadow: var(--shadow);
    }

    .rec-status {
      text-align: center;
      color: var(--muted);
      margin-top: 6px;
      min-height: 18px;
    }

    canvas {
      width: 100%;
      background: #000;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 160px;
      touch-action: none;
    }

    /* Preselection – smaller, subtle */
    #preCanvas {
      height: 80px;
      background: #0a0a0a;
      cursor: crosshair;
    }

    .handles {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .handles .center {
      text-align: center;
      color: #d7d7d7;
      font-weight: 600;
    }

    .tiny {
      font-size: 13px;
      padding: 6px 10px;
    }

    .pill {
      border-radius: 999px;
      padding: 8px 12px;
    }

    /* Settings controls */
    .settings-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 20px;
    }

    .field label {
      font-size: 13px;
      color: var(--muted);
      display: inline-block;
      margin-bottom: 6px;
    }

    /* Green themed slider */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 280px;
      height: 6px;
      border-radius: 999px;
      background: #2a2a2a;
      outline: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0e0e0e;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
      transition: transform .12s ease, background .18s ease;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent-hover);
      transform: scale(1.06);
    }

    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35);
    }

    input[type=range]::-moz-range-track {
      background: #2a2a2a;
      height: 6px;
      border-radius: 999px;
    }

    .status {
      min-height: 20px;
      color: var(--muted);
    }

    /* Effects grid */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 14px;
    }

    .preset-card {
      background: #1e1e1e;
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      padding: 14px;
      display: grid;
      gap: 10px;
      box-shadow: var(--shadow);
    }

    .preset-card h3 {
      margin: 0;
      font-size: 18px;
      font-family: Oswald, sans-serif;
    }

    .mini-wrap {
      border-radius: 10px;
      overflow: hidden;
      background: #0a0a0a;
    }

    .mini-wave {
      width: 100%;
      height: 60px;
      background: #0a0a0a;
      display: block;
    }

    .curve-vis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .curve {
      position: relative;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      background: #0a0a0a;
      padding: 8px;
    }

    .curve h4 {
      position: absolute;
      top: 6px;
      left: 10px;
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, .5);
      font-weight: 600;
    }

    .curve canvas {
      width: 100%;
      height: 100px;
      border: none;
      background: transparent;
    }

    .preset-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .preset-actions .primary,
    .preset-actions .btn-ghost {
      width: 100%;
    }

    .btn-ghost {
      background: #141414;
      border: 1px solid #2a2a2a;
      color: var(--text);
    }

    .meta {
      color: #6f6f6f;
      font-size: 13px;
    }

    .meta b {
      color: #cfcfcf;
      font-weight: 700;
    }

    /* Pulse animatie voor record */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }

      50% {
        box-shadow: 0 0 0 12px rgba(239, 68, 68, .6);
      }

      100% {
        box-shadow: 0 0 0 6px rgba(239, 68, 68, .3);
      }
    }

    /* State classes */
    .recording .record-dot {
      background: var(--danger);
      animation: pulse 1.2s infinite;
    }

    .recording .stop-square {
      background: var(--white);
      opacity: 1;
    }

    .idle .stop-square {
      background: var(--white);
      opacity: 0.3;
    }

    .idle .record-dot {
      background: var(--danger);
      animation: none;
    }

    .round-icon.small {
      width: 44px;
      height: 44px;
      margin: 4px;
    }

    /* Icon wrappers centreren */
    .round-icon.small .icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Play driehoekje */
    .icon-play {
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-left: 14px solid var(--white);
    }

    .icon-stop {
      width: 14px;
      height: 14px;
      background: var(--white);
    }

    /* Pause icon */
    .icon-pause {
      display: flex;
      gap: 4px;
    }

    .icon-pause span {
      display: block;
      width: 4px;
      height: 14px;
      background: var(--white);
    }

    .preset-actions button {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    /* Enabled state after generate */
    .preset-actions.enabled button {
      opacity: 1;
      cursor: pointer;
      pointer-events: auto;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <header>
    <h1>Sample Scratcher</h1>
  </header>

  <main>
    <!-- 1) Load Sample – full dropzone with centered refined recording controls -->
    <section class="panel elev" id="loadPanel">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drag and drop audio here or browse files">
        <div class="dz-inner">
          <span class="big-plus">+</span>
          <div class="dz-title">Drag & Drop Sample</div>
          <div><span class="dz-browse" id="browseLink">Or Browse Files</span></div>
          <input id="fileInput" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="rec-controls-wrap">
        <div class="rec-controls">
          <button id="recordBtn" class="round-icon" title="Record"><span class="record-dot"></span></button>
          <button id="stopBtn" class="round-icon" title="Stop" disabled><span class="stop-square"></span></button>
        </div>
        <div class="rec-status" id="recStatus">No sample loaded…</div>
      </div>
    </section>

    <section class="panel" id="prePanel">
      <div class="section-title">
        <h2 id="fileSubtitle">Preselection</h2>
        <div class="row">
          <button id="reloadSampleBtn" class="tiny pill ghost" disabled>Reset</button>
          <button id="commitPreBtn" class="tiny pill primary" disabled>Cut Sample</button>
          <button id="prePlayBtn" class="round-icon small" title="Preview" disabled>
            <div class="icon icon-play"></div>
          </button>
        </div>
      </div>
      <canvas id="preCanvas" width="900" height="80"></canvas>
      <div class="handles">
        <span>Cut start: <span id="preStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="preLenLbl">0.00s</span></span>
        <span>Cut end: <span id="preEndLbl">0.00s</span></span>
      </div>
    </section>

    <!-- 3) Scratching Area -->
    <section class="panel">
      <div class="section-title">
        <h2>Scratching Area</h2>
      </div>
      <canvas id="waveCanvas" width="900" height="160" aria-label="Scratching waveform"></canvas>
      <div class="handles">
        <span>Start: <span id="clipStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="clipLenLbl">0.15s</span></span>
        <span>End: <span id="clipEndLbl">0.15s</span></span>
      </div>
    </section>

    <!-- 4) Settings (Torque + Tail switch) -->
    <section class="panel">
      <div class="section-title">
        <h2>Settings</h2>
      </div>
      <div class="settings-row">
        <div class="field">
          <label for="bpm">BPM</label>
          <input id="bpm" type="number" value="120" min="40" max="300" step="1" />
        </div>
        <div class="field">
  <label for="slipMode">Slip Mode</label><br />
  <input id="slipMode" type="checkbox" />
</div>
        <button id="generateBtn" class="primary" style="font-size:18px; padding:14px 28px; border-radius:999px;"
          disabled>
          Generate Samples
        </button>
      </div>
    </section>

    <!-- 5) Effects -->
    <section class="panel">
      <div class="section-title">
        <h2>Effects</h2>
      </div>
      <div id="presetGrid" class="preset-grid"></div>
    </section>
  </main>

  <template id="presetCardTpl">
    <div class="preset-card">
      <h3 class="pname"></h3>
      <div class="mini-wrap">
        <canvas class="mini-wave" width="300" height="54"></canvas>
      </div>
      <div class="meta"><span>Duration: <b class="beats">1 beat</b></span></div>
      <div class="preset-actions">
        <button class="playBtn primary">Play</button>
        <button class="dlBtn btn-ghost">Download</button>
      </div>
    </div>
  </template>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let mediaRecorder, chunks = [];
    let sampleBuffer = null;
    let originalSampleBuffer = null;
    let sampleFileName = '';

    let preStart = 0, preEnd = 0;
    let clipStart = 0, clipEnd = 0.15;

    let rafId = null;
    let playhead = { active: false, startAt: 0, duration: 0, where: 'none', canvas: null, miniIdx: -1 };

    let mainSrc = null;

    let presetSrc = null;

    let presetBuffers = [];

    const slipModeEl = document.getElementById('slipMode');

    const recStatus = document.getElementById('recStatus');
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const browseLink = document.getElementById('browseLink');

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recControls = document.querySelector('.rec-controls');
    let recTimerInterval = null;
    let recStartTime = null;

    const fileSubtitle = document.getElementById('fileSubtitle');
    const preCanvas = document.getElementById('preCanvas');
    const preCtx = preCanvas.getContext('2d');
    const preStartLbl = document.getElementById('preStartLbl');
    const preEndLbl = document.getElementById('preEndLbl');
    const preLenLbl = document.getElementById('preLenLbl');
    const reloadSampleBtn = document.getElementById('reloadSampleBtn');
    const prePlayBtn = document.getElementById('prePlayBtn');
    const commitPreBtn = document.getElementById('commitPreBtn');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');
    const clipStartLbl = document.getElementById('clipStartLbl');
    const clipEndLbl = document.getElementById('clipEndLbl');
    const clipLenLbl = document.getElementById('clipLenLbl');

    const bpmEl = document.getElementById('bpm');
    const globalStatus = document.getElementById('globalStatus');

    const presetGrid = document.getElementById('presetGrid');
    const presetCardTpl = document.getElementById('presetCardTpl');

    const generateBtn = document.getElementById('generateBtn');

    // ==== helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function sampleLinear(chData, pos) { const i = Math.floor(pos), f = pos - i; const i2 = Math.min(chData.length - 1, i + 1); return lerp(chData[i] || 0, chData[i2] || 0, f); }
    function secToX(sec, duration, width) { const ratio = duration ? (sec / duration) : 0; return Math.round(clamp(ratio, 0, 1) * (width - 1)); }
    function xToSec(x, duration, width) { const ratio = x / (width - 1); return ratio * (duration || 0); }

    function fitCanvasToDisplay(canvas) { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); const need = canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr); if (need) { canvas.width = Math.max(1, Math.round(rect.width * dpr)); canvas.height = Math.max(1, Math.round(rect.height * dpr)); } return dpr; }
    function canvasEventX(e, canvas) { const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect(); return clamp((e.clientX - r.left) * dpr, 0, canvas.width - 1); }

    function updateLabels() {
      clipStartLbl.textContent = (clipStart || 0).toFixed(2) + 's';
      clipEndLbl.textContent = (clipEnd || 0).toFixed(2) + 's';
      clipLenLbl.textContent = Math.max(0, (clipEnd - clipStart)).toFixed(2) + 's';
      preStartLbl.textContent = (preStart || 0).toFixed(2) + 's';
      preEndLbl.textContent = (preEnd || 0).toFixed(2) + 's';
      preLenLbl.textContent = Math.max(0, (preEnd - preStart)).toFixed(2) + 's';
    }

    // ==== drawing
    function drawPreWave() {
      const dpr = fitCanvasToDisplay(preCanvas);
      const Wp = preCanvas.width, Hp = preCanvas.height;
      preCtx.clearRect(0, 0, Wp, Hp);
      preCtx.fillStyle = '#0a0a0a';
      preCtx.fillRect(0, 0, Wp, Hp);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wp));
      preCtx.strokeStyle = '#666';
      preCtx.lineWidth = Math.max(1, dpr);
      preCtx.beginPath();
      for (let x = 0; x < Wp; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * Hp;
        if (x === 0) preCtx.moveTo(x, y); else preCtx.lineTo(x, y);
      }
      preCtx.stroke();

      // Draw selection shading + handles
      const sX = secToX(preStart, sampleBuffer.duration, Wp);
      const eX = secToX(preEnd, sampleBuffer.duration, Wp);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      preCtx.fillStyle = 'rgba(34,197,94,0.18)';
      preCtx.fillRect(a, 0, Math.max(1, b - a), Hp);

      preCtx.strokeStyle = '#22c55e';
      preCtx.lineWidth = Math.max(2, 2 * dpr);
      preCtx.beginPath(); preCtx.moveTo(sX, 0); preCtx.lineTo(sX, Hp); preCtx.stroke();
      preCtx.beginPath(); preCtx.moveTo(eX, 0); preCtx.lineTo(eX, Hp); preCtx.stroke();

      // --- FIXED: playhead line ---
      if (playhead.active && playhead.where === 'pre') {
        const elapsed = audioCtx.currentTime - playhead.startAt;
        const rel = Math.min(elapsed, playhead.duration);   // clamp to selection length
        const x = secToX(preStart + rel, sampleBuffer.duration, Wp);
        preCtx.strokeStyle = '#ffffff';
        preCtx.lineWidth = Math.max(1, dpr);
        preCtx.beginPath();
        preCtx.moveTo(x, 0);
        preCtx.lineTo(x, Hp);
        preCtx.stroke();
      }
    }

    function drawMainWave() {
      const dpr = fitCanvasToDisplay(waveCanvas);
      const Wc = waveCanvas.width, Hc = waveCanvas.height;
      waveCtx.clearRect(0, 0, Wc, Hc);
      waveCtx.fillStyle = '#000'; waveCtx.fillRect(0, 0, Wc, Hc);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wc));
      waveCtx.strokeStyle = '#16a34a';
      waveCtx.lineWidth = Math.max(1, dpr);
      waveCtx.beginPath();
      for (let x = 0; x < Wc; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hc; if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y); }
      waveCtx.stroke();

      const sX = secToX(clipStart, sampleBuffer.duration, Wc), eX = secToX(clipEnd, sampleBuffer.duration, Wc);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)'; waveCtx.fillRect(a, 0, Math.max(1, b - a), Hc);

      waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = Math.max(2, 2 * dpr);
      waveCtx.beginPath(); waveCtx.moveTo(sX, 0); waveCtx.lineTo(sX, Hc); waveCtx.stroke();
      waveCtx.beginPath(); waveCtx.moveTo(eX, 0); waveCtx.lineTo(eX, Hc); waveCtx.stroke();

      // Play circle only (white mid bar removed for easier drag)
      const midX = Math.round((a + b) / 2);
      const r = 14 * dpr; const cy = Hc / 2;
      const isPlaying = playhead.active && playhead.where === 'main';
      waveCtx.beginPath(); waveCtx.arc(midX, cy, r, 0, Math.PI * 2); waveCtx.fillStyle = '#111'; waveCtx.fill(); waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = 2 * dpr; waveCtx.stroke();
      waveCtx.fillStyle = '#fff';
      if (!isPlaying) { const px = midX - 5 * dpr, py = cy - 7 * dpr; waveCtx.beginPath(); waveCtx.moveTo(px, py); waveCtx.lineTo(px, py + 14 * dpr); waveCtx.lineTo(px + 12 * dpr, cy); waveCtx.closePath(); waveCtx.fill(); }
      else {
        const size = 12 * dpr;
        waveCtx.fillRect(midX - size / 2, cy - size / 2, size, size);
      }

      if (playhead.active && playhead.where === 'main') {
        const p = clamp((audioCtx.currentTime - playhead.startAt) / playhead.duration, 0, 1);
        const x = a + p * (b - a);
        waveCtx.strokeStyle = '#ffffff'; waveCtx.lineWidth = Math.max(1, dpr);
        waveCtx.beginPath(); waveCtx.moveTo(x, 0); waveCtx.lineTo(x, Hc); waveCtx.stroke();
      }
    }

    function drawMiniFromBuffer(canvas, buffer, playPct = null) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, w, h);
      if (!buffer) return;
      const data = buffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / w));
      ctx.strokeStyle = '#16a34a'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let x = 0; x < w; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * h; if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
      ctx.stroke();
      if (playPct != null) { const x = clamp(Math.round(playPct * (w - 1)), 0, w - 1); ctx.strokeStyle = '#fff'; ctx.lineWidth = Math.max(1, dpr); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    }

    function drawCurve(canvas, arr, lo, hi, label) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, w, h);
      if (!arr) return;
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let i = 0; i < w; i++) {
        const t = w > 1 ? i / (w - 1) : 0; const idx = Math.floor(t * (arr.length - 1));
        const v = arr[idx];
        const y = (1 - (v - lo) / (hi - lo)) * h;
        if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
      }
      ctx.stroke();
      // subtle label inside
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      ctx.font = `${12 * dpr}px system-ui, sans-serif`;
      const text = label || '';
      if (text) ctx.fillText(text, 10 * dpr, 18 * dpr);
    }

    // ==== load / record
    async function loadArrayBuffer(arr, name = '') {
      sampleBuffer = await audioCtx.decodeAudioData(arr);
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;
      preStart = 0; preEnd = sampleBuffer.duration;
      clipStart = 0; clipEnd = Math.min(0.15, sampleBuffer.duration);
      recStatus.textContent = `Sample: ${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate} Hz`;
      prePlayBtn.disabled = false; commitPreBtn.disabled = false; reloadSampleBtn.disabled = false;
      generateBtn.disabled = false;
      drawPreWave(); drawMainWave(); updateLabels();
    }

    dropzone.addEventListener('click', () => fileInput.click());
    browseLink.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
    dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', async (e) => { e.preventDefault(); dropzone.classList.remove('hover'); const file = e.dataTransfer.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); });
    fileInput.onchange = async (e) => { const file = e.target.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); };

    const startRecording = async () => {
      await audioCtx.resume();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => e.data && chunks.push(e.data);
      mediaRecorder.onstop = async () => { const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' }); const arr = await blob.arrayBuffer(); await loadArrayBuffer(arr, 'Recorded Sample'); };
      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;

      // Zet state class
      recControls.classList.remove('idle');
      recControls.classList.add('recording');

      // Start timer
      recStartTime = Date.now();
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = setInterval(() => {
        const elapsed = ((Date.now() - recStartTime) / 1000).toFixed(1);
        recStatus.textContent = `Recording… ${elapsed}s`;
      }, 200);
    };
    recordBtn.onclick = startRecording;
    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); stopBtn.disabled = true; recordBtn.disabled = false; // Reset state
      recControls.classList.remove('recording');
      recControls.classList.add('idle');

      // Stop timer
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = null;
      recStatus.textContent = 'Stopped. Processing sample…';
    };

    // ==== Preselection interactions
    let preDragging = null; // 'start' | 'end' | 'move' | 'new'
    const HANDLE_EPS = 12 * (window.devicePixelRatio || 1);

    function preHitTest(x) {
      const sX = secToX(preStart, sampleBuffer?.duration, preCanvas.width);
      const eX = secToX(preEnd, sampleBuffer?.duration, preCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updatePreCursor(e) { if (!sampleBuffer) { preCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, preCanvas); const kind = preHitTest(x); preCanvas.style.cursor = (kind === 'move') ? 'grab' : (kind === 'start' || kind === 'end') ? 'ew-resize' : 'crosshair'; }

    preCanvas.addEventListener('pointermove', (e) => {
      if (!preDragging) updatePreCursor(e);
      if (!sampleBuffer || !preDragging) return;
      const x = canvasEventX(e, preCanvas);
      const sec = xToSec(x, sampleBuffer.duration, preCanvas.width);
      if (preDragging === 'start') preStart = Math.min(sec, preEnd - 0.005);
      else if (preDragging === 'end') preEnd = Math.max(sec, preStart + 0.005);
      else if (preDragging === 'move') { const width = preEnd - preStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); preStart = ns; preEnd = ns + width; }
      else if (preDragging === 'new') { preEnd = Math.max(sec, 0); preStart = Math.min(sec, preStart); }
      drawPreWave(); updateLabels();
    });
    preCanvas.addEventListener('pointerdown', (e) => { if (!sampleBuffer) return; preCanvas.setPointerCapture(e.pointerId); const x = canvasEventX(e, preCanvas); const ht = preHitTest(x); if (ht === 'new') { const sec = xToSec(x, sampleBuffer.duration, preCanvas.width); preStart = sec; preEnd = sec; } preDragging = ht; updatePreCursor(e); });
    preCanvas.addEventListener('pointerup', (e) => { preDragging = null; preCanvas.releasePointerCapture(e.pointerId); updatePreCursor(e); });
    preCanvas.addEventListener('pointerleave', () => { preDragging = null; preCanvas.style.cursor = 'crosshair'; });

    let preSrc = null;

    function setPreBtnState(state) {
      prePlayBtn.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'icon';

      if (state === 'play') {
        const icon = document.createElement('div');
        icon.className = 'icon-play';
        wrapper.appendChild(icon);
      } else if (state === 'stop') {
        const icon = document.createElement('div');
        icon.className = 'icon-stop';
        wrapper.appendChild(icon);
      }

      prePlayBtn.appendChild(wrapper);
    }

    prePlayBtn.onclick = () => {
      if (!sampleBuffer) return;

      if (preSrc) {
        // already playing → stop
        preSrc.stop();
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
        return;
      }

      // create new buffer with selection
      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
      };

      src.start();
      preSrc = src;
      setPreBtnState('stop');
      startPlayhead('pre', (preEnd - preStart));
    };

    commitPreBtn.onclick = () => {
      if (!sampleBuffer) return;
      const chs = sampleBuffer.numberOfChannels; const sr = sampleBuffer.sampleRate; const len = Math.max(1, Math.floor((preEnd - preStart) * sr)); const newBuf = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) { const inData = sampleBuffer.getChannelData(ch); const outData = newBuf.getChannelData(ch); const startIdx = Math.floor(preStart * sr); for (let i = 0; i < len; i++) { outData[i] = inData[startIdx + i] || 0; } }
      sampleBuffer = newBuf; preStart = 0; preEnd = sampleBuffer.duration; clipStart = 0; clipEnd = Math.min(0.15, sampleBuffer.duration);
      drawPreWave(); drawMainWave(); updateLabels(); globalStatus.textContent = 'Preselection applied as new sample';
    };

    reloadSampleBtn.onclick = () => {
      if (!originalSampleBuffer) return;
      sampleBuffer = originalSampleBuffer;   // restore
      preStart = 0;
      preEnd = sampleBuffer.duration;
      clipStart = 0;
      clipEnd = Math.min(0.20, sampleBuffer.duration);

      drawPreWave();
      drawMainWave();
      updateLabels();
      globalStatus.textContent = 'Sample reloaded to original state';
    };

    // ==== main selection with play circle (no visible mid bar)
    let dragging = null; // 'start' | 'end' | 'move'
    const MAIN_HANDLE_EPS = 14 * (window.devicePixelRatio || 1);

    function isInsidePlayCircle(x, y) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      const midX = (a + b) / 2;
      const cy = waveCanvas.height / 2;

      const dpr = (window.devicePixelRatio || 1);
      const r = 14 * dpr;

      // echte afstand check
      const dx = x - midX;
      const dy = y - cy;
      return dx * dx + dy * dy <= r * r;
    }

    function mainHitTest(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);

      if (Math.abs(x - sX) <= MAIN_HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= MAIN_HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updateMainCursor(e) {
      if (!sampleBuffer) {
        waveCanvas.style.cursor = 'not-allowed';
        return;
      }

      const x = canvasEventX(e, waveCanvas);
      const y = (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1);

      // Check playbutton eerst
      if (isInsidePlayCircle(x, y)) {
        waveCanvas.style.cursor = 'pointer';
        return;
      }

      const ht = mainHitTest(x);

      if (ht === 'move') {
        waveCanvas.style.cursor = 'grab';
      } else if (ht === 'start' || ht === 'end') {
        waveCanvas.style.cursor = 'ew-resize';
      } else if (ht === 'new') {
        waveCanvas.style.cursor = 'crosshair'; // vrij selecteren
      } else {
        waveCanvas.style.cursor = 'default';
      }
    }

    waveCanvas.addEventListener('pointerdown', (e) => {
      if (!sampleBuffer) return;
      waveCanvas.setPointerCapture(e.pointerId);
      const x = canvasEventX(e, waveCanvas);
      if (isInsidePlayCircle(x, (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1))) {
        if (playhead.active && playhead.where === 'main') {
          stopPlayhead();
        } else {
          playClipSelection();
        }
        return;
      }
      const ht = mainHitTest(x);
      if (ht === 'new') {
        const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
        clipStart = sec;
        clipEnd = sec;
      }
      dragging = ht;
    });
    waveCanvas.addEventListener('pointermove', (e) => {
      if (!dragging) updateMainCursor(e);
      if (!sampleBuffer || !dragging) return;
      const x = canvasEventX(e, waveCanvas);
      const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
      if (dragging === 'start') clipStart = Math.min(sec, clipEnd - 0.005);
      else if (dragging === 'end') clipEnd = Math.max(sec, clipStart + 0.005);
      else if (dragging === 'move') { const width = clipEnd - clipStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); clipStart = ns; clipEnd = ns + width; }
      else if (dragging === 'new') {
        clipEnd = Math.max(sec, 0);
        clipStart = Math.min(sec, clipStart);
      }
      drawMainWave(); updateLabels();
    });
    waveCanvas.addEventListener('pointerup', (e) => { dragging = null; waveCanvas.releasePointerCapture(e.pointerId); updateMainCursor(e); });
    waveCanvas.addEventListener('pointerleave', () => { dragging = null; waveCanvas.style.cursor = 'crosshair'; });

    function playClipSelection() {
      if (!sampleBuffer) return;

      // stop eventueel vorige afspeler
      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((clipEnd - clipStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(clipStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        mainSrc = null;
        stopPlayhead();
      };

      src.start();
      mainSrc = src;

      startPlayhead('main', (clipEnd - clipStart));
    }

    function curveFromFormula(formula, samples, lo, hi) {
      let fn; try { fn = new Function('t', `return (${formula});`); } catch (err) { throw new Error('Formula error: ' + err.message); }
      const arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) { const t = samples > 1 ? i / (samples - 1) : 0; let v; try { v = fn(t); } catch (e) { v = 0; } if (!Number.isFinite(v)) v = 0; arr[i] = clamp(v, lo, hi); }
      return arr;
    }

    async function renderEffectToBuffer(preset) {
  if (!sampleBuffer) throw new Error('No sample loaded or recorded.');

  const bpm = parseFloat(bpmEl.value || '120');
  const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
  const beats = parseInt(preset.duration, 10) || 1;
  const scratchDur = beatDur * beats;

  const sr = sampleBuffer.sampleRate;
  const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
  const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
  const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

  const sStart = Math.floor(clipStart * sr);
  const sEnd = Math.floor(clipEnd * sr);
  const sLen = Math.max(1, sEnd - sStart);

  const outLen = scratchSamples;
  let out = new AudioBuffer({
    length: outLen,
    numberOfChannels: sampleBuffer.numberOfChannels,
    sampleRate: sr
  });

  let lastPos = sStart;

  for (let ch = 0; ch < out.numberOfChannels; ch++) {
    const inData = sampleBuffer.getChannelData(ch);
    const outData = out.getChannelData(ch);

    // --- Scratch part ---
    for (let i = 0; i < scratchSamples; i++) {
      const u = (scratchCurve[i] + 1) * 0.5;
      const srcPos = sStart + u * (sLen - 1);
      lastPos = srcPos;
      const v = sampleLinear(inData, srcPos);
      outData[i] = v * gainCurve[i];
    }

    if (scratchSamples > 0) {
      const v = sampleLinear(inData, lastPos);
      outData[scratchSamples - 1] = v * gainCurve[scratchSamples - 1];
    }

    // Fade in/out
    const fadeSamples = Math.floor(sr * 0.003);
    for (let i = 0; i < fadeSamples; i++) {
      const t = i / fadeSamples;
      outData[i] *= t;
      const j = outData.length - 1 - i;
      if (j >= 0) outData[j] *= t;
    }
  }

  // === Slip Mode continuation ===
  if (slipModeEl.checked) {
    const slipRemaining = Math.max(0, sampleBuffer.length - Math.floor(lastPos));
    const slipSamples = slipRemaining;

    const extended = new AudioBuffer({
      length: out.length + slipSamples,
      numberOfChannels: out.numberOfChannels,
      sampleRate: sr
    });

    // Copy scratch part
    for (let c = 0; c < out.numberOfChannels; c++) {
      extended.getChannelData(c).set(out.getChannelData(c), 0);
    }

    // Fill slip continuation
    for (let c = 0; c < out.numberOfChannels; c++) {
      const inData = sampleBuffer.getChannelData(c);
      const extData = extended.getChannelData(c);
      let pos = Math.floor(lastPos);
      for (let i = 0; i < slipSamples; i++) {
        extData[out.length + i] = inData[pos + i] || 0;
      }
    }

    out = extended;
  }

  const offline = new OfflineAudioContext(out.numberOfChannels, out.length, out.sampleRate);
  const src = offline.createBufferSource();
  src.buffer = out;
  src.connect(offline.destination);
  src.start();
  const rendered = await offline.startRendering();
  return rendered;
}

    // ==== Presets
    let presets = [
      {
        name: "Classic",
        duration: "1",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.25)?((2*(3*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25)-2*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25)*((((t%1+1)%1)-0)/0.25))-1)):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.5)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25)-2*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25)*((((t%1+1)%1)-0.25)/0.25))-1))):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.75)?((2*(3*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25)-2*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25)*((((t%1+1)%1)-0.5)/0.25))-1)):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<1)?(-1*((2*(3*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25)-2*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25)*((((t%1+1)%1)-0.75)/0.25))-1))):0)",
        gainFormula: "1"
      },
      {
        name: "Classic 2",
        duration: "2",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.125)?((2*(3*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)-2*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125))-1)):0)+((((t%1+1)%1)>=0.125&&((t%1+1)%1)<0.25)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.125)/0.125))))+1):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.375)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125)-2*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125)*((((t%1+1)%1)-0.25)/0.125))-1))):0)+((((t%1+1)%1)>=0.375&&((t%1+1)%1)<0.5)?((2*(3*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125)-2*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125)*((((t%1+1)%1)-0.375)/0.125))-1)):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.625)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.5)/0.125))))+1):0)+((((t%1+1)%1)>=0.625&&((t%1+1)%1)<0.75)?(-1*((2*(3*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125)-2*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125)*((((t%1+1)%1)-0.625)/0.125))-1))):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.875)?((2*(3*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125)-2*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125)*((((t%1+1)%1)-0.75)/0.125))-1)):0)+((((t%1+1)%1)>=0.875&&((t%1+1)%1)<1)?((0*(Math.sin(2*Math.PI*((((t%1+1)%1)-0.875)/0.125))))+1):0)",
        gainFormula: "1"
      },
      {
        name: "Hood Scratch",
        duration: "3",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.083333)?((2*(3*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333)-2*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333)*((((t%1+1)%1)-0)/0.083333))-1)):0)+((((t%1+1)%1)>=0.083333&&((t%1+1)%1)<0.166667)?(-1*((2*(3*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333)-2*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333)*((((t%1+1)%1)-0.083333)/0.083333))-1))):0)+((((t%1+1)%1)>=0.166667&&((t%1+1)%1)<0.25)?((2*(3*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333)-2*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333)*((((t%1+1)%1)-0.166667)/0.083333))-1)):0)+((((t%1+1)%1)>=0.25&&((t%1+1)%1)<0.333333)?(-1*((2*(3*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333)-2*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333)*((((t%1+1)%1)-0.25)/0.083333))-1))):0)+((((t%1+1)%1)>=0.333333&&((t%1+1)%1)<0.416667)?((2*(3*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333)-2*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333)*((((t%1+1)%1)-0.333333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.416667&&((t%1+1)%1)<0.5)?((0*((2*(3*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333)-2*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333)*((((t%1+1)%1)-0.416667)/0.083333))-1)))+1):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.583333)?(-1*((2*(3*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333)-2*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333)*((((t%1+1)%1)-0.5)/0.083333))-1))):0)+((((t%1+1)%1)>=0.583333&&((t%1+1)%1)<0.666667)?((2*(3*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333)-2*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333)*((((t%1+1)%1)-0.583333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.666667&&((t%1+1)%1)<0.75)?((0*((2*(3*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333)-2*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333)*((((t%1+1)%1)-0.666667)/0.083333))-1)))+1):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.833333)?(-1*((2*(3*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333)-2*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333)*((((t%1+1)%1)-0.75)/0.083333))-1))):0)+((((t%1+1)%1)>=0.833333&&((t%1+1)%1)<0.916667)?((2*(3*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333)-2*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333)*((((t%1+1)%1)-0.833333)/0.083333))-1)):0)+((((t%1+1)%1)>=0.916667&&((t%1+1)%1)<1)?((0*((2*(3*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333)-2*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333)*((((t%1+1)%1)-0.916667)/0.083333))-1)))+1):0)",
        gainFormula: "1"
      },
      {
        name: "Hood Scratch 2",
        duration: "4",
        scratchFormula: "((((t%1+1)%1)>=0&&((t%1+1)%1)<0.125)?((2*(3*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)-2*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125)*((((t%1+1)%1)-0)/0.125))-1)):0)+((((t%1+1)%1)>=0.125&&((t%1+1)%1)<0.3125)?((0*((2*(3*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875)-2*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875)*((((t%1+1)%1)-0.125)/0.1875))-1)))+1):0)+((((t%1+1)%1)>=0.3125&&((t%1+1)%1)<0.375)?(-1*((2*(3*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625)-2*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625)*((((t%1+1)%1)-0.3125)/0.0625))-1))):0)+((((t%1+1)%1)>=0.375&&((t%1+1)%1)<0.4375)?((2*(3*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625)-2*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625)*((((t%1+1)%1)-0.375)/0.0625))-1)):0)+((((t%1+1)%1)>=0.4375&&((t%1+1)%1)<0.5)?(-1*((2*(3*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625)-2*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625)*((((t%1+1)%1)-0.4375)/0.0625))-1))):0)+((((t%1+1)%1)>=0.5&&((t%1+1)%1)<0.5625)?((2*(3*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625)-2*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625)*((((t%1+1)%1)-0.5)/0.0625))-1)):0)+((((t%1+1)%1)>=0.5625&&((t%1+1)%1)<0.625)?((0*((2*(3*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625)-2*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625)*((((t%1+1)%1)-0.5625)/0.0625))-1)))+1):0)+((((t%1+1)%1)>=0.625&&((t%1+1)%1)<0.6875)?(-1*((2*(3*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625)-2*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625)*((((t%1+1)%1)-0.625)/0.0625))-1))):0)+((((t%1+1)%1)>=0.6875&&((t%1+1)%1)<0.75)?((2*(3*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625)-2*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625)*((((t%1+1)%1)-0.6875)/0.0625))-1)):0)+((((t%1+1)%1)>=0.75&&((t%1+1)%1)<0.8125)?((0*((2*(3*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625)-2*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625)*((((t%1+1)%1)-0.75)/0.0625))-1)))+1):0)+((((t%1+1)%1)>=0.8125&&((t%1+1)%1)<0.875)?(-1*((2*(3*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625)-2*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625)*((((t%1+1)%1)-0.8125)/0.0625))-1))):0)+((((t%1+1)%1)>=0.875&&((t%1+1)%1)<0.9375)?((2*(3*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625)-2*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625)*((((t%1+1)%1)-0.875)/0.0625))-1)):0)+((((t%1+1)%1)>=0.9375&&((t%1+1)%1)<1)?((0*((2*(3*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625)-2*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625)*((((t%1+1)%1)-0.9375)/0.0625))-1)))+1):0)",
        gainFormula: "1"
      }
    ];

    async function renderPresetGrid(forceRedrawWaves = false) {
      presetGrid.innerHTML = '';
      presets.forEach((p, idx) => {
        const node = presetCardTpl.content.cloneNode(true);
        node.querySelector('.pname').textContent = p.name;
        node.querySelector('.beats').textContent = `${p.duration} beat(s)`;
        const card = node.querySelector('.preset-card');
        const mini = node.querySelector('.mini-wave');
        const cScratch = node.querySelector('.curve-scratch');
        const cGain = node.querySelector('.curve-gain');
        const playBtn = node.querySelector('.playBtn');
        const dlBtn = node.querySelector('.dlBtn');

        // initial curves + mini waveform prerender
        const sr = sampleBuffer?.sampleRate || 44100;
        const bpm = parseFloat(bpmEl.value || '120');
        const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
        const samples = Math.max(1, Math.floor((beatDur * (parseInt(p.duration) || 1)) * sr));

        if (sampleBuffer) {
          const preview = synthesizePreviewBuffer(p);
          drawMiniFromBuffer(mini, preview, null);
        }

        playBtn.addEventListener('click', async () => { const i = idx; await handlePlayPreset(i, playBtn, mini); });
        dlBtn.addEventListener('click', async () => { const i = idx; await handleDownloadPreset(i); });
        mini.addEventListener('click', async () => { await handlePlayPreset(idx, playBtn, mini); });

        presetGrid.appendChild(node);
      });
    }

    function synthesizePreviewBuffer(preset) {
  if (!sampleBuffer) return null;

  const bpm = parseFloat(bpmEl.value || '120');
  const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
  const beats = parseInt(preset.duration, 10) || 1;
  const scratchDur = beatDur * beats;

  const sr = sampleBuffer.sampleRate;
  const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
  const scratchCurve = curveFromFormula(preset.scratchFormula, scratchSamples, -1, 1);
  const gainCurve = curveFromFormula(preset.gainFormula, scratchSamples, 0, 1);

  const sStart = Math.floor(clipStart * sr);
  const sEnd = Math.floor(clipEnd * sr);
  const sLen = Math.max(1, sEnd - sStart);

  let out = new AudioBuffer({ length: scratchSamples, numberOfChannels: 1, sampleRate: sr });
  const inData = sampleBuffer.getChannelData(0);
  const outData = out.getChannelData(0);

  let lastPos = sStart;

  // Scratch part
  for (let i = 0; i < scratchSamples; i++) {
    const u = (scratchCurve[i] + 1) * 0.5;
    const srcPos = sStart + u * (sLen - 1);
    lastPos = srcPos;
    const v = sampleLinear(inData, srcPos);
    outData[i] = v * gainCurve[i];
  }

  if (scratchSamples > 0) {
    const v = sampleLinear(inData, lastPos);
    outData[scratchSamples - 1] = v * gainCurve[scratchSamples - 1];
  }

  // Fade in/out
  const fadeSamples = Math.floor(sr * 0.003);
  for (let i = 0; i < fadeSamples; i++) {
    const t = i / fadeSamples;
    outData[i] *= t;
    const j = outData.length - 1 - i;
    if (j >= 0) outData[j] *= t;
  }

  // === Slip Mode continuation ===
  if (slipModeEl.checked) {
    const slipRemaining = Math.max(0, sampleBuffer.length - Math.floor(lastPos));
    const slipSamples = slipRemaining;

    const extended = new AudioBuffer({
      length: out.length + slipSamples,
      numberOfChannels: 1,
      sampleRate: sr
    });

    extended.getChannelData(0).set(out.getChannelData(0), 0);

    let pos = Math.floor(lastPos);
    const extData = extended.getChannelData(0);
    for (let i = 0; i < slipSamples; i++) {
      extData[out.length + i] = inData[pos + i] || 0;
    }

    out = extended;
  }

  return out;
}

    async function updatePresetThumbnails() {

      // Then loop over all preset cards and draw mini-wave previews
      const cards = presetGrid.querySelectorAll('.preset-card');
      cards.forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (!mini) return;
        const preview = synthesizePreviewBuffer(presets[idx]);
        if (preview) {
          drawMiniFromBuffer(mini, preview, null);
        }
      });
    }

    async function handlePlayPreset(i, buttonEl, miniCanvas) {
      try {
        await audioCtx.resume();

        // stop if already playing
        if (presetSrc) {
          presetSrc.stop();
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          return;
        }

        // use cached buffer
        const rendered = presetBuffers[i];
        if (!rendered) {
          globalStatus.textContent = "Preset not generated yet. Click Generate first!";
          return;
        }

        const src = audioCtx.createBufferSource();
        src.buffer = rendered;
        src.connect(audioCtx.destination);

        src.onended = () => {
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
        };

        src.start();
        presetSrc = src;

        buttonEl.textContent = 'Stop';
        startPlayhead('mini', rendered.duration, miniCanvas, i);
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    async function handleDownloadPreset(i) { try { const rendered = await renderEffectToBuffer(presets[i]); const wav = audioBufferToWav(rendered); const url = URL.createObjectURL(wav); const a = document.createElement('a'); a.href = url; a.download = `${presets[i].name.replace(/[^a-z0-9_-]+/ig, '_')}.wav`; a.click(); globalStatus.textContent = `${presets[i].name} downloaded`; } catch (err) { globalStatus.textContent = err.message; } }

    function audioBufferToWav(buffer) { const numCh = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const length = buffer.length; const bps = 2; const blockAlign = numCh * bps; const byteRate = sampleRate * blockAlign; const dataSize = length * blockAlign; const total = 44 + dataSize; const ab = new ArrayBuffer(total); const dv = new DataView(ab); let p = 0; function w8(v) { dv.setUint8(p++, v); } function w16(v) { dv.setUint16(p, v, true); p += 2; } function w32(v) { dv.setUint32(p, v, true); p += 4; } w8(0x52); w8(0x49); w8(0x46); w8(0x46); w32(36 + dataSize); w8(0x57); w8(0x41); w8(0x56); w8(0x45); w8(0x66); w8(0x6d); w8(0x74); w8(0x20); w32(16); w16(1); w16(numCh); w32(sampleRate); w32(byteRate); w16(blockAlign); w16(16); w8(0x64); w8(0x61); w8(0x74); w8(0x61); w32(dataSize); const chans = []; for (let ch = 0; ch < numCh; ch++) chans.push(buffer.getChannelData(ch)); for (let i = 0; i < length; i++) { for (let ch = 0; ch < numCh; ch++) { let s = Math.max(-1, Math.min(1, chans[ch][i])); s = s < 0 ? s * 0x8000 : s * 0x7fff; dv.setInt16(p, s, true); p += 2; } } return new Blob([ab], { type: 'audio/wav' }); }

    function startPlayhead(where, duration, canvas = null, miniIdx = -1, onEnd = null) {
      playhead.active = true; playhead.startAt = audioCtx.currentTime; playhead.duration = duration; playhead.where = where; playhead.canvas = canvas; playhead.miniIdx = miniIdx; if (rafId) cancelAnimationFrame(rafId);
      const tick = () => {
        const t = audioCtx.currentTime - playhead.startAt; if (t >= duration) { stopPlayhead(); onEnd && onEnd(); return; } if (where === 'main') drawMainWave(); else if (where === 'pre') drawPreWave(); else if (where === 'mini' && canvas) {
          const buf = presetBuffers[miniIdx];  // use cached buffer
          if (buf) drawMiniFromBuffer(canvas, buf, t / duration);
        } rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function stopPlayhead() {
      playhead.active = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      if (presetSrc) {
        presetSrc.stop();
        presetSrc = null;
      }

      if (playhead.where === 'main') drawMainWave();
      if (playhead.where === 'pre') drawPreWave();
      if (playhead.where === 'mini' && playhead.canvas) {
        const buf = presetBuffers[playhead.miniIdx];  // use cached buffer
        if (buf) drawMiniFromBuffer(playhead.canvas, buf, null);
      }
      playhead.where = 'none';
    }

    function init() { fitCanvasToDisplay(preCanvas); fitCanvasToDisplay(waveCanvas); drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(); recControls.classList.add('idle'); setPreBtnState('play'); }
    init();

    generateBtn.addEventListener('click', async () => {
      renderPresetGrid(true);
      updatePresetThumbnails();

      // cache rendered buffers
      presetBuffers = [];
      for (let i = 0; i < presets.length; i++) {
        try {
          const rendered = await renderEffectToBuffer(presets[i]);
          presetBuffers[i] = rendered;
        } catch (err) {
          presetBuffers[i] = null;
          console.error("Preset render failed:", err);
        }
      }

      // Enable buttons with animation
      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-actions').forEach((el, idx) => {
          setTimeout(() => el.classList.add('enabled'), idx * 100); // stagger enable
        });
      });
    });

  </script>
</body>

</html>
