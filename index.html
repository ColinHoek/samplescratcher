<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <title>Sample Scratcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
  <!-- Axios for API calls -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <!-- Authentication & Download Manager -->
  <script src="auth.js" defer></script>
  <link rel="stylesheet" href="auth.css" />
</head>

<body>

  <div class="logo-container">
    <a href="https://carpaudio.com/" aria-label="CARP Audio home" target="_blank" rel="noopener noreferrer">
      <img src="icons/ss-logo.svg" alt="Sample Scratcher Logo" class="ss-logo" />
    </a>

    <!-- User Menu -->
    <div id="userMenu" class="user-menu">
      <button id="upgradeBtn" class="upgrade-btn" style="display:none;">
  Upgrade to Unlimited
</button>
      <button id="loginBtn" class="pill primary">
  <img src="icons/user-icon.svg" alt="" class="icon-user">
  <span>Login</span>
</button>
      <div id="userInfo" class="user-info" style="display:none;">
        <div class="user-details">
          <div id="userName" class="user-name"></div>
          <div id="downloadStatus" class="download-status"></div>
        </div>
        <button id="logoutBtn" class="pill ghost tiny">Logout</button>
      </div>
    </div>
  </div>

  <main>
    <!-- 1) Load Sample – full dropzone with centered refined recording controls -->
    <section class="panel elev" id="loadPanel">
      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drag and drop audio here or browse files">
        <div class="dz-inner">
          <span class="big-plus">+</span>
          <div class="dz-title">Drag & Drop Sample</div>
          <div><span class="dz-browse" id="browseLink">Or Browse Files</span></div>
          <input id="fileInput" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="rec-controls-wrap">
        <div class="rec-controls">
          <button id="recordBtn" class="round-icon" title="Record"><span class="record-dot"></span></button>
          <button id="stopBtn" class="round-icon" title="Stop" disabled><span class="stop-square"></span></button>
        </div>
        <div class="rec-status" id="recStatus">No sample loaded…</div>
      </div>
    </section>

    <section class="panel" id="prePanel">
      <div class="section-title">
        <h2 id="fileSubtitle"></h2>
        <div class="row" style="margin-bottom: 10px;">
          <button id="reloadSampleBtn" class="tiny pill ghost" disabled>Reset</button>
          <button id="commitPreBtn" class="tiny pill primary" disabled>Cut Sample</button>
          <button id="prePlayBtn" class="round-icon small" title="Preview" disabled>
            <div class="icon icon-play"></div>
          </button>
        </div>
      </div>
      <canvas id="preCanvas" width="900" height="80"></canvas>
      <div class="handles">
        <span>Start: <span id="preStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="preLenLbl" class="value">0.00s</span></span>
        <span>End: <span id="preEndLbl">0.00s</span></span>
      </div>
    </section>

    <!-- 3) Scratching Area -->
    <section class="panel">
      <div class="section-title">
        <div class="section-title">
  <h2>Scratch Area</h2>
  <img src="icons/info-icon.svg" alt="Info" class="info-icon" id="infoIcon">
</div>
      </div>
      <canvas id="waveCanvas" width="900" height="160" aria-label="Scratching waveform"></canvas>
      <div class="handles">
        <span>Start: <span id="clipStartLbl">0.00s</span></span>
        <span class="center">Length: <span id="clipLenLbl" class="value">0.10s</span></span>
        <span>End: <span id="clipEndLbl">0.10s</span></span>
      </div>
    </section>

    <!-- 4) Settings -->
    <section class="panel" id="settingsPanel">
      <div class="section-title">
        <h2>Sample Generation</h2>
      </div>
      <div class="settings-row">
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">BPM</span>
          <input id="bpm" type="number" value="120" min="40" max="300" step="1" />
        </div>
        <div class="field switch-field">
          <span style=" padding:7px" class="switch-label">Continue Playback</span>
          <label class="switch" title="Continue Playback after Scratching">
            <input id="slipMode" type="checkbox" />
            <span class="slider round"></span>
          </label>
        </div>
        <div class="field switch-field">
          <span style="padding:7px" class="switch-label">Vinyl Noise</span>
          <label class="switch" title="Scratch with Dusty Vinyl">
            <input id="vinylNoise" type="checkbox" checked />
            <span class="slider round"></span>
          </label>
        </div>
        <div class="field switch-field">
          <span style="padding:7px" class="switch-label">Humanize</span>
          <label class="switch" title="Add subtle human imperfections to scratching">
            <input id="humanizeScratch" type="checkbox" checked />
            <span class="slider round"></span>
          </label>
        </div>
        <button id="generateBtn" class="primary"
          style="font-size:20px; margin-left:auto; margin-right: 3px; padding:10px 90px 10px 90px; border-radius:999px; font-family: Oswald, sans-serif;"
          disabled>
          Generate Samples
        </button>
      </div>
    </section>

    <!-- 5) Effects -->
    <section class="panel" id="effectsPanel">
      <div id="presetGrid" class="preset-grid"></div>
    </section>
  </main>

  <template id="presetCardTpl">
    <div class="preset-card">
      <div class="section-title">
        <div class="left-group">
          <h3 class="pname"></h3>
          <button class="option-pill hidden no-hover" title="Scratch Variation">Option</button>
          <button class="reload-btn no-hover" title="Render Again">
            <svg width="800px" height="800px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none">
              <path fill="#ffffff"
                d="M7.248 1.307A.75.75 0 118.252.193l2.5 2.25a.75.75 0 010 1.114l-2.5 2.25a.75.75 0 01-1.004-1.114l1.29-1.161a4.5 4.5 0 103.655 2.832.75.75 0 111.398-.546A6 6 0 118.018 2l-.77-.693z" />
            </svg>
          </button>
        </div>
        <span class="beat-icon" title="Duration in Beat(s)"></span>
      </div>
      <div class="mini-wrap">
        <canvas class="mini-wave" width="300" height="54"></canvas>
      </div>
      <div class="meta">
        Duration: <span class="duration"></span>
      </div>
      <div class="preset-actions">
        <button class="playBtn primary">Play</button>
        <button class="dlBtn btn-ghost">Download</button>
      </div>
    </div>
  </template>

  <div class="screen-overlay-container">
    <div class="bubble-container" id="bubbleContainer"></div>
  </div>

  <!-- Auth Modal -->
  <div id="authModal" class="modal">
    <div class="modal-content">
      <button class="modal-close">&times;</button>
      <div class="logo-container2">
    <a href="https://carpaudio.com/" aria-label="CARP Audio home" target="_blank" rel="noopener noreferrer">
      <img src="icons/carp-logo.svg" alt="CARP Audio Home" class="carp-audio-logo" id="carp-logo">
    </a>
  </div>
      <div class="modal-tabs">
        <button id="loginTab" class="modal-tab active">Login</button>
        <button id="registerTab" class="modal-tab">Register</button>
      </div>

      <!-- Login Form -->
      <form id="loginForm" class="auth-form">
        <!-- Register By Email -->
        <div class="form-group">
          <label for="loginEmail">Email</label>
          <input type="email" id="loginEmail" required />
        </div>
        <div class="form-group">
          <label for="loginPassword" style="margin-top: 5px;">Password</label>
          <input type="password" id="loginPassword" required />
        </div>
        <div id="loginError" class="error-message"></div>
        <div class="forgot-password">
          <a href="https://dashboard.carpaudio.com/auth/reset" id="forgotPasswordLink" style="justify-content: left;">Forgot password?</a>
        </div>
        <button type="submit" class="primary" style="margin-top: 30px;">Login</button>


        <div class="divider"><span>or</span></div>

        <!-- Google Login Button -->
        <button type="button" id="googleLoginBtn" class="google-login-btn">
          <img src="icons/google-logo.svg" alt="Google Logo" style="width:18px; height:18px; margin-right:10px;" />
          Continue with Google
        </button>
      </form>

      <!-- Register Form -->
      <form id="registerForm" class="auth-form" style="display:none;">
        <!-- Register By Email -->
        <div class="form-group">
          <label for="registerName">Name</label>
          <input type="text" id="registerName" required />
        </div>
        <div class="form-group">
          <label for="registerEmail" style="margin-top: 5px;">Email</label>
          <input type="email" id="registerEmail" required />
        </div>
        <div class="form-group">
          <label for="registerPassword" style="margin-top: 5px;">Password</label>
          <input type="password" id="registerPassword" required minlength="8" />
          <small>At least 8 characters</small>
        </div>
        <div class="form-group optin-group">
          <label class="optin-label">
            <input type="checkbox" id="newsletterOptIn" />
            <span>I'd like to receive updates and news by email</span>
          </label>
        </div>
        <div id="registerError" class="error-message"></div>
        <button type="submit" class="primary" style="margin-top: 20px;">Create Account</button>

        <div class="divider"><span>or</span></div>

        <!-- Google Sign Up Button -->
        <button type="button" id="googleRegisterBtn" class="google-login-btn">
          <img src="icons/google-logo.svg" alt="Google Logo" style="width:18px; height:18px; margin-right:10px;" />
          Sign up with Google
        </button>  
      </form>
    </div>
  </div>

  <!-- Upgrade Modal Limit Reached -->
  <div id="upgradeModal" class="modal">
    <div class="modal-content">
      <button class="modal-close">&times;</button>
      <img src="icons/ss-logo.svg" alt="Sample Scratcher Logo" class="ss-logo" />
      <h2>Download Limit Reached</h2>
      <!-- TODO -->
      <p>You've used all 2 free downloads for today.</p>
      <div class="upgrade-benefits">
        <h3>Upgrade to Unlimited</h3>
        <ul>
          <li>✓ One-time payment of €19,95</li>
          <li>✓ Unlimited downloads</li>
          <li>✓ No daily limits</li>
          <li>✓ Lifetime access</li>
        </ul>
      </div>
      <a href="https://carpaudio.com/products/sample-scratcher-unlimited" target="_blank" class="primary" style="display:inline-block; width: 100%; border-radius: 999px; padding:12px 40px; text-align: center; text-decoration:none; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;">
        Upgrade Now
      </a>
      <!-- TODO -->
      <p style="margin-top:20px; font-size:14px; color:#999;">
        Your 2 free downloads will reset tomorrow at midnight UTC.
      </p>
    </div>
  </div>

  <!-- Upgrade Modal -->
  <div id="upgradePromoModal" class="modal">
    <div class="modal-content">
      <button class="modal-close">&times;</button>
      <img src="icons/ss-logo.svg" alt="Sample Scratcher Logo" class="ss-logo" />
      <h2>Need unlimited downloads?</h2>
      <p>Add Sample Scratcher to your toolbox!</p>
      <div class="upgrade-benefits">
        <h3>Upgrade to Unlimited</h3>
        <ul>
          <li>✓ One-time payment of €19,95</li>
          <li>✓ Unlimited downloads</li>
          <li>✓ No daily limits</li>
          <li>✓ Lifetime access</li>
        </ul>
      </div>
      <a href="https://carpaudio.com/products/sample-scratcher-unlimited" target="_blank" class="primary" style="display:inline-block; width: 100%; border-radius: 999px; padding:12px 40px; text-align: center; text-decoration:none; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;">
        Upgrade Now
      </a>
    </div>
  </div>

  <!-- Info Popup -->
<div id="infoModal" class="modal">
  <div class="modal-content">
    <button class="modal-close" id="infoClose">&times;</button>
    <img src="icons/info-icon.svg" style="height: 50px; width: 50px;" alt="Info" class="info-icon" id="infoIcon">
    <h2>Scratch Area</h2>
    <p>
      The Scratch Area represents the section of the audio sample that the algorithm will scratch with. Just like on a real turntable, this is the area of the record where the needle dances back and forth over when scratching.
    </p>
    <ul>
      <li><b>Click & drag</b> to create a selection.</li>
      <li><b>Preview</b> your selection by clicking the play button in the center of the selection.</li>
      <li><b>Adjust</b> the selection at any time and regenerate all scratches, or just one specific scratch, by changing the duration, variation or by clicking the small reload icon next to the scratch title.</li>
    </ul>
  </div>
</div>

  <footer>
    © 2025. <a href="https://carpaudio.com/" title="">CARP Audio</a>. All rights reserved.
  </footer>

  <script>
    // =========================
    // API Configuration
    // =========================
    // Development: use localhost
    // Production: use Vercel URL
    window.API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '0.0.0.0'
      ? 'http://localhost:3000'
      : 'https://sample-scratcher-api.vercel.app';

    console.log('API URL:', window.API_URL);

    axios.defaults.baseURL = window.API_URL;
    axios.defaults.withCredentials = false; // We use JWT tokens, not cookies (except for Google OAuth)

    // =========================
    // Audio Context
    // =========================
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let mediaRecorder, chunks = [];
    let mediaStream = null;
    let sampleBuffer = null;
    let originalSampleBuffer = null;
    let sampleFileName = '';

    let preStart = 0, preEnd = 0;
    let clipStart = 0, clipEnd = 0.10;

    let rafId = null;
    let playhead = { active: false, startAt: 0, duration: 0, where: 'none', canvas: null, miniIdx: -1 };

    let mainSrc = null;

    let presetSrc = null;

    let presetBuffers = [];

    let presetBeats = [];

    let lastGeneratedWithSlip = false; // onthoud slip state bij Generate

    const slipModeEl = document.getElementById('slipMode');

    const recStatus = document.getElementById('recStatus');
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const browseLink = document.getElementById('browseLink');

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recControls = document.querySelector('.rec-controls');
    let recTimerInterval = null;
    let recStartTime = null;

    const fileSubtitle = document.getElementById('fileSubtitle');
    const preCanvas = document.getElementById('preCanvas');
    const preCtx = preCanvas.getContext('2d');
    const preStartLbl = document.getElementById('preStartLbl');
    const preEndLbl = document.getElementById('preEndLbl');
    const preLenLbl = document.getElementById('preLenLbl');
    const reloadSampleBtn = document.getElementById('reloadSampleBtn');
    const prePlayBtn = document.getElementById('prePlayBtn');
    const commitPreBtn = document.getElementById('commitPreBtn');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');
    const clipStartLbl = document.getElementById('clipStartLbl');
    const clipEndLbl = document.getElementById('clipEndLbl');
    const clipLenLbl = document.getElementById('clipLenLbl');

    const bpmEl = document.getElementById('bpm');
    const globalStatus = document.getElementById('globalStatus');

    const presetGrid = document.getElementById('presetGrid');
    const presetCardTpl = document.getElementById('presetCardTpl');

    const generateBtn = document.getElementById('generateBtn');

    const humanizeScratchEl = document.getElementById('humanizeScratch');

    // === Make BPM field draggable (scrubbable) ===
    let bpmDragActive = false;
    let bpmStartY = 0;
    let bpmStartValue = 0;

    bpmEl.style.cursor = 'ns-resize'; // up/down cursor for hint

    bpmEl.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // left-click only
      bpmDragActive = true;
      bpmStartY = e.clientY;
      bpmStartValue = parseFloat(bpmEl.value) || 120;
      document.body.style.userSelect = 'none'; // prevent text highlighting
    });

    window.addEventListener('mousemove', (e) => {
      if (!bpmDragActive) return;

      const deltaY = bpmStartY - e.clientY; // dragging up increases BPM
      const sensitivity = 0.25; // adjust for finer or faster control
      let newBpm = bpmStartValue + deltaY * sensitivity;

      newBpm = Math.round(newBpm);
      newBpm = Math.max(40, Math.min(300, newBpm)); // clamp to input range
      bpmEl.value = newBpm;
    });

    window.addEventListener('mouseup', () => {
      if (bpmDragActive) {
        bpmDragActive = false;
        document.body.style.userSelect = '';
      }
    });

    // Vinyl Noise
    const vinylNoiseEl = document.getElementById('vinylNoise');
    const VINYL_NOISE_VOLUME = 0.20; // hardcoded: lager = subtieler

    let noiseBuffers = [];

    // ==== helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function sampleLinear(chData, pos) { const i = Math.floor(pos), f = pos - i; const i2 = Math.min(chData.length - 1, i + 1); return lerp(chData[i] || 0, chData[i2] || 0, f); }
    // Higher-quality interpolation (4-point cubic Hermite)
    function sampleCubic(chData, pos) {
      const i = Math.floor(pos);
      const frac = pos - i;

      const y0 = chData[i - 1] || 0;
      const y1 = chData[i] || 0;
      const y2 = chData[i + 1] || 0;
      const y3 = chData[i + 2] || 0;

      const a = (-0.5 * y0) + (1.5 * y1) - (1.5 * y2) + (0.5 * y3);
      const b = y0 - (2.5 * y1) + (2 * y2) - (0.5 * y3);
      const c = (-0.5 * y0) + (0.5 * y2);
      const d = y1;

      return a * frac * frac * frac + b * frac * frac + c * frac + d;
    }
    function secToX(sec, duration, width) { const ratio = duration ? (sec / duration) : 0; return Math.round(clamp(ratio, 0, 1) * (width - 1)); }
    function xToSec(x, duration, width) { const ratio = x / (width - 1); return ratio * (duration || 0); }

    function fitCanvasToDisplay(canvas) { const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect(); const need = canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr); if (need) { canvas.width = Math.max(1, Math.round(rect.width * dpr)); canvas.height = Math.max(1, Math.round(rect.height * dpr)); } return dpr; }
    function canvasEventX(e, canvas) { const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect(); return clamp((e.clientX - r.left) * dpr, 0, canvas.width - 1); }

    function updateLabels() {
      clipStartLbl.textContent = (clipStart || 0).toFixed(2) + 's';
      clipEndLbl.textContent = (clipEnd || 0).toFixed(2) + 's';
      clipLenLbl.textContent = Math.max(0, (clipEnd - clipStart)).toFixed(2) + 's';

      preStartLbl.textContent = (preStart || 0).toFixed(2) + 's';
      preEndLbl.textContent = (preEnd || 0).toFixed(2) + 's';

      const preLen = Math.max(0, (preEnd - preStart));
      const lenStr = preLen.toFixed(2) + 's';
      preLenLbl.innerHTML = (Math.abs(preLen - 10) < 0.005)
        ? `${lenStr} (<span style="color:#22c55e;">Max</span>)`
        : lenStr;
    }

    // ==== drawing
    function drawPreWave() {
      const dpr = fitCanvasToDisplay(preCanvas);
      const Wp = preCanvas.width, Hp = preCanvas.height;
      preCtx.clearRect(0, 0, Wp, Hp);
      preCtx.fillStyle = '#121212';
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      preCtx.fillRect(0, 0, Wp, Hp);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wp));
      preCtx.strokeStyle = '#666';
      preCtx.lineWidth = Math.max(1, dpr);
      preCtx.beginPath();
      for (let x = 0; x < Wp; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * Hp;
        if (x === 0) preCtx.moveTo(x, y); else preCtx.lineTo(x, y);
      }
      preCtx.stroke();

      // Draw selection shading + handles
      const sX = secToX(preStart, sampleBuffer.duration, Wp);
      const eX = secToX(preEnd, sampleBuffer.duration, Wp);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      preCtx.fillStyle = 'rgba(34,197,94,0.18)';
      preCtx.fillRect(a, 0, Math.max(1, b - a), Hp);

      preCtx.strokeStyle = '#22c55e';
      preCtx.lineWidth = Math.max(2, 2 * dpr);
      preCtx.beginPath(); preCtx.moveTo(sX, 0); preCtx.lineTo(sX, Hp); preCtx.stroke();
      preCtx.beginPath(); preCtx.moveTo(eX, 0); preCtx.lineTo(eX, Hp); preCtx.stroke();

      // --- FIXED: playhead line ---
      if (playhead.active && playhead.where === 'pre') {
        const elapsed = audioCtx.currentTime - playhead.startAt;
        const rel = Math.min(elapsed, playhead.duration);   // clamp to selection length
        const x = secToX(preStart + rel, sampleBuffer.duration, Wp);
        preCtx.strokeStyle = '#ffffff';
        preCtx.lineWidth = Math.max(1, dpr);
        preCtx.beginPath();
        preCtx.moveTo(x, 0);
        preCtx.lineTo(x, Hp);
        preCtx.stroke();
      }
    }

    function drawMainWave() {
      const dpr = fitCanvasToDisplay(waveCanvas);
      const Wc = waveCanvas.width, Hc = waveCanvas.height;
      waveCtx.clearRect(0, 0, Wc, Hc);
      waveCtx.fillStyle = '#121212'; waveCtx.fillRect(0, 0, Wc, Hc);
      if (!sampleBuffer) return;

      const data = sampleBuffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / Wc));
      waveCtx.strokeStyle = '#16a34a';
      waveCtx.lineWidth = Math.max(1, dpr);
      waveCtx.shadowColor = '#22c55e4A';
      waveCtx.shadowBlur = 8;
      waveCtx.beginPath();
      for (let x = 0; x < Wc; x++) { const v = data[x * step] || 0; const y = (1 - (v + 1) / 2) * Hc; if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y); }
      waveCtx.stroke();

      const sX = secToX(clipStart, sampleBuffer.duration, Wc), eX = secToX(clipEnd, sampleBuffer.duration, Wc);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      waveCtx.fillStyle = 'rgba(255,255,255,0.06)'; waveCtx.fillRect(a, 0, Math.max(1, b - a), Hc);

      waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = Math.max(2, 2 * dpr);
      waveCtx.beginPath(); waveCtx.moveTo(sX, 0); waveCtx.lineTo(sX, Hc); waveCtx.stroke();
      waveCtx.beginPath(); waveCtx.moveTo(eX, 0); waveCtx.lineTo(eX, Hc); waveCtx.stroke();

      // Play circle only (white mid bar removed for easier drag)
      const midX = Math.round((a + b) / 2);
      const r = 14 * dpr; const cy = Hc / 2;
      const isPlaying = playhead.active && playhead.where === 'main';
      waveCtx.beginPath(); waveCtx.arc(midX, cy, r, 0, Math.PI * 2); waveCtx.fillStyle = '#111'; waveCtx.fill(); waveCtx.strokeStyle = '#fff'; waveCtx.lineWidth = 2 * dpr; waveCtx.stroke();
      waveCtx.fillStyle = '#fff';
      if (!isPlaying) { const px = midX - 5 * dpr, py = cy - 7 * dpr; waveCtx.beginPath(); waveCtx.moveTo(px, py); waveCtx.lineTo(px, py + 14 * dpr); waveCtx.lineTo(px + 12 * dpr, cy); waveCtx.closePath(); waveCtx.fill(); }
      else {
        const size = 12 * dpr;
        waveCtx.fillRect(midX - size / 2, cy - size / 2, size, size);
      }

      if (playhead.active && playhead.where === 'main') {
        const p = clamp((audioCtx.currentTime - playhead.startAt) / playhead.duration, 0, 1);
        const x = a + p * (b - a);
        waveCtx.strokeStyle = '#ffffff'; waveCtx.lineWidth = Math.max(1, dpr);
        waveCtx.beginPath(); waveCtx.moveTo(x, 0); waveCtx.lineTo(x, Hc); waveCtx.stroke();
      }
    }

    function drawMiniFromBuffer(canvas, buffer, playPct = null, beats = 1) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212';
      ctx.fillRect(0, 0, w, h);
      if (!buffer) return;

      // waveform tekenen
      const data = buffer.getChannelData(0);
      const step = Math.max(1, Math.floor(data.length / w));
      ctx.strokeStyle = '#16a34a';
      ctx.lineWidth = Math.max(1, dpr);
      ctx.shadowColor = '#22c55e4A';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const v = data[x * step] || 0;
        const y = (1 - (v + 1) / 2) * h;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // beat-lijntjes tekenen (alleen als slip uit stond bij generate)
      if (!lastGeneratedWithSlip && beats > 1) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5 * dpr;
        for (let b = 1; b < beats; b++) {
          const x = Math.round((b / beats) * w);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
      }

      // playhead tekenen
      if (playPct != null) {
        const x = clamp(Math.round(playPct * (w - 1)), 0, w - 1);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, dpr);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
    }


    function drawCurve(canvas, arr, lo, hi, label) {
      const dpr = fitCanvasToDisplay(canvas);
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#121212'; ctx.fillRect(0, 0, w, h);
      if (!arr) return;
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth = Math.max(1, dpr);
      ctx.beginPath();
      for (let i = 0; i < w; i++) {
        const t = w > 1 ? i / (w - 1) : 0; const idx = Math.floor(t * (arr.length - 1));
        const v = arr[idx];
        const y = (1 - (v - lo) / (hi - lo)) * h;
        if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
      }
      ctx.stroke();
      // subtle label inside
      ctx.fillStyle = 'rgba(255,255,255,.4)';
      ctx.font = `${12 * dpr}px system-ui, sans-serif`;
      const text = label || '';
      if (text) ctx.fillText(text, 10 * dpr, 18 * dpr);
    }

    async function loadNoiseBuffers() {
      const bufs = [];
      for (let i = 1; i <= 10; i++) {
        const url = `noise/noise${String(i).padStart(2, '0')}.wav`;
        const res = await fetch(url);
        const arr = await res.arrayBuffer();
        const buf = await audioCtx.decodeAudioData(arr);
        bufs.push(buf);
      }
      noiseBuffers = bufs;
      console.log("Loaded noise samples:", noiseBuffers.length);
    }

    function mixWithNoise(mainBuffer) {
      if (!vinylNoiseEl.checked || noiseBuffers.length === 0) return mainBuffer;

      // random noise sample
      const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
      const noiseOffset = Math.floor(Math.random() * noise.length);

      // nieuwe buffer voor mix
      const mixed = audioCtx.createBuffer(
        mainBuffer.numberOfChannels,
        mainBuffer.length,
        mainBuffer.sampleRate
      );

      for (let ch = 0; ch < mainBuffer.numberOfChannels; ch++) {
        const mainData = mainBuffer.getChannelData(ch);
        const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
        const mixedData = mixed.getChannelData(ch);

        for (let i = 0; i < mainBuffer.length; i++) {
          const n = noiseData[(i + noiseOffset) % noise.length]; // random start
          mixedData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
        }
      }
      return mixed;
    }

    // ==== load / record
    async function loadArrayBuffer(arr, name = '') {
      const maxSizeMB = 200;
      if (arr.byteLength > maxSizeMB * 1024 * 1024) {
        recStatus.textContent = `❌ File too large (${(arr.byteLength / 1024 / 1024).toFixed(1)} MB). Max allowed is ${maxSizeMB} MB.`;
        return;
      }

      // only decode if file is within limit
      const decoded = await audioCtx.decodeAudioData(arr);

      sampleBuffer = decoded;
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;

      sampleBuffer = decoded;
      originalSampleBuffer = sampleBuffer;
      sampleFileName = name || 'Sample';
      fileSubtitle.textContent = sampleFileName;

      // default selection
      preStart = 0;
      preEnd = Math.min(1, sampleBuffer.duration);
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      // === enforce 10-second rule ===
      if (sampleBuffer.duration > 10) {
        recStatus.innerHTML = 'Please cut a sample from the file! (<span style="color:#22c55e;">Max 10s</span>)';
        disableScratchArea(true);        // hide / disable scratch canvas
        commitPreBtn.disabled = false;
        reloadSampleBtn.disabled = false;
        prePlayBtn.disabled = false;
        generateBtn.disabled = true;

        // draw only the preselection waveform
        drawPreWave();

        // clear scratch area so no waveform is visible
        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
        waveCtx.fillStyle = '#121212';
        waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
        const message = 'Cut a sample from the audio file. (Max 10s)';

        // Device pixel ratio for sharpness
        const dpr = window.devicePixelRatio || 1;

        // Smaller, more balanced font scaling
        // ~12px on phones, ~16px on desktop (before DPR scaling)
        const baseFont = window.innerWidth < 600 ? 12 : 16;
        waveCtx.font = `${baseFont * dpr}px system-ui`;
        waveCtx.fillStyle = '#777';

        // Optional soft shadow for readability
        waveCtx.shadowColor = 'rgba(0,0,0,0.3)';
        waveCtx.shadowBlur = 2;

        // Center message
        const metrics = waveCtx.measureText(message);
        const x = (waveCanvas.width - metrics.width) / 2;
        const y = (waveCanvas.height / 2) + baseFont * dpr * 0.4;
        waveCtx.fillText(message, x, y);

        waveCtx.fillText(message, x, y);
      } else {
        recStatus.textContent = `Sample: ${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate} Hz`;
        disableScratchArea(false);
        commitPreBtn.disabled = false;
        reloadSampleBtn.disabled = false;
        prePlayBtn.disabled = false;
        generateBtn.disabled = false;

        // draw both
        drawPreWave();
        drawMainWave();
      }

      updateLabels();
      updateTouchAction();
    }

    function disableScratchArea(disabled) {
      const waveCanvas = document.getElementById('waveCanvas');
      if (disabled) {
        waveCanvas.style.pointerEvents = 'none';
        generateBtn.disabled = true;
      } else {
        waveCanvas.style.pointerEvents = 'auto';
      }
    }

    dropzone.addEventListener('click', () => fileInput.click());
    browseLink.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
    dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', async (e) => { e.preventDefault(); dropzone.classList.remove('hover'); const file = e.dataTransfer.files?.[0]; if (!file) return; const arr = await file.arrayBuffer(); await loadArrayBuffer(arr, file.name); });
    fileInput.onchange = async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const maxSizeMB = 200;
      if (file.size > maxSizeMB * 1024 * 1024) {
        recStatus.textContent = `❌ File too large (${(file.size / 1024 / 1024).toFixed(1)} MB). Max allowed is ${maxSizeMB} MB.`;
        return;
      }

      const arr = await file.arrayBuffer();
      await loadArrayBuffer(arr, file.name);
    };


    const startRecording = async () => {
      await audioCtx.resume();

      if (!mediaStream || !mediaStream.active) {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      }

      mediaRecorder = new MediaRecorder(mediaStream);
      chunks = [];

      mediaRecorder.ondataavailable = e => e.data && chunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
        const arr = await blob.arrayBuffer();
        await loadArrayBuffer(arr, 'Recorded Sample');
      };

      mediaRecorder.start();
      recordBtn.disabled = true;
      stopBtn.disabled = false;

      recControls.classList.remove('idle');
      recControls.classList.add('recording');

      recStartTime = Date.now();
      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = setInterval(() => {
        const elapsed = ((Date.now() - recStartTime) / 1000).toFixed(1);
        recStatus.textContent = `Recording… ${elapsed}s`;
      }, 200);
    };
    recordBtn.onclick = startRecording;
    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }

      stopBtn.disabled = true;
      recordBtn.disabled = false;

      recControls.classList.remove('recording');
      recControls.classList.add('idle');

      if (recTimerInterval) clearInterval(recTimerInterval);
      recTimerInterval = null;

      recStatus.textContent = 'Stopped. Processing sample…';
    };

    // ==== Preselection interactions
    let preDragging = null; // 'start' | 'end' | 'move' | 'new'
    const HANDLE_EPS = 12 * (window.devicePixelRatio || 1);

    function preHitTest(x) {
      const sX = secToX(preStart, sampleBuffer?.duration, preCanvas.width);
      const eX = secToX(preEnd, sampleBuffer?.duration, preCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      if (Math.abs(x - sX) <= HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updatePreCursor(e) { if (!sampleBuffer) { preCanvas.style.cursor = 'not-allowed'; return; } const x = canvasEventX(e, preCanvas); const kind = preHitTest(x); preCanvas.style.cursor = (kind === 'move') ? 'grab' : (kind === 'start' || kind === 'end') ? 'ew-resize' : 'crosshair'; }

    preCanvas.addEventListener('pointermove', (e) => {
      if (!preDragging) updatePreCursor(e);
      if (!sampleBuffer || !preDragging) return;

      const x = canvasEventX(e, preCanvas);
      const sec = xToSec(x, sampleBuffer.duration, preCanvas.width);
      const MAX_LEN = 10; // limit preselection to 10 seconds

      if (preDragging === 'start') {
        preStart = Math.min(sec, preEnd - 0.005);
        if (preEnd - preStart > MAX_LEN) {
          preStart = preEnd - MAX_LEN;
        }
      } else if (preDragging === 'end') {
        preEnd = Math.max(sec, preStart + 0.005);
        if (preEnd - preStart > MAX_LEN) {
          preEnd = preStart + MAX_LEN;
        }
      } else if (preDragging === 'move') {
        const width = Math.min(preEnd - preStart, MAX_LEN);
        let ns = sec - width / 2;
        ns = clamp(ns, 0, sampleBuffer.duration - width);
        preStart = ns;
        preEnd = ns + width;
      } else if (preDragging === 'new') {
        // new drag selection
        preEnd = sec;
        if (preEnd < preStart) {
          [preStart, preEnd] = [preEnd, preStart];
        }
        // clamp if dragged too far
        if (preEnd - preStart > MAX_LEN) {
          preEnd = preStart + MAX_LEN;
        }
      }

      // keep inside buffer duration
      preStart = clamp(preStart, 0, sampleBuffer.duration);
      preEnd = clamp(preEnd, 0, sampleBuffer.duration);

      drawPreWave();
      updateLabels();
    });

    preCanvas.addEventListener('pointerdown', (e) => { if (!sampleBuffer) return; preCanvas.setPointerCapture(e.pointerId); const x = canvasEventX(e, preCanvas); const ht = preHitTest(x); if (ht === 'new') { const sec = xToSec(x, sampleBuffer.duration, preCanvas.width); preStart = sec; preEnd = sec; } preDragging = ht; updatePreCursor(e); });
    preCanvas.addEventListener('pointerup', (e) => { preDragging = null; preCanvas.releasePointerCapture(e.pointerId); updatePreCursor(e); });
    preCanvas.addEventListener('pointerleave', () => { preDragging = null; preCanvas.style.cursor = 'crosshair'; });

    let preSrc = null;

    function setPreBtnState(state) {
      prePlayBtn.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'icon';

      if (state === 'play') {
        const icon = document.createElement('div');
        icon.className = 'icon-play';
        wrapper.appendChild(icon);
      } else if (state === 'stop') {
        const icon = document.createElement('div');
        icon.className = 'icon-stop';
        wrapper.appendChild(icon);
      }

      prePlayBtn.appendChild(wrapper);
    }

    prePlayBtn.onclick = () => {
      if (!sampleBuffer) return;

      if (preSrc) {
        // already playing → stop
        preSrc.stop();
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
        return;
      }

      // create new buffer with selection
      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        preSrc = null;
        stopPlayhead();
        setPreBtnState('play');
      };

      src.start();
      preSrc = src;
      setPreBtnState('stop');
      startPlayhead('pre', (preEnd - preStart));
    };

    commitPreBtn.onclick = () => {
      if (!sampleBuffer) return;

      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((preEnd - preStart) * sr));

      const newBuf = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = newBuf.getChannelData(ch);
        const startIdx = Math.floor(preStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }

      sampleBuffer = newBuf;
      preStart = 0;
      preEnd = sampleBuffer.duration;
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      if (sampleBuffer.duration <= 10) {
        recStatus.textContent = `Audio file has been cut to a ${sampleBuffer.duration.toFixed(2)}s sample.`;
        disableScratchArea(false);
        generateBtn.disabled = false;
      } else {
        recStatus.textContent = "Please cut the sample to 10 seconds or shorter.";
        disableScratchArea(true);
      }

      drawPreWave();
      drawMainWave();
      updateLabels();
    };

    reloadSampleBtn.onclick = () => {
      if (!originalSampleBuffer) return;

      // Restore the full original audio for preselection
      sampleBuffer = originalSampleBuffer;
      preStart = 0;
      preEnd = Math.min(1, sampleBuffer.duration);
      clipStart = 0;
      clipEnd = Math.min(0.10, sampleBuffer.duration);

      // If file is longer than 10s → disable scratching again
      if (sampleBuffer.duration > 10) {
        recStatus.innerHTML = `Full file reloaded (${sampleBuffer.duration.toFixed(2)}s). Please cut a sample again! <span style="color:#22c55e;">(Max 10s)</span>`;
        disableScratchArea(true);

        // Clear the scratch waveform
        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
        waveCtx.fillStyle = '#121212';
        waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);

        const msg = 'Cut a sample from the audio file. (Max 10s)';

        // Device pixel ratio for sharpness
        const dpr = window.devicePixelRatio || 1;

        // Balanced font scaling: ~12px mobile, ~16px desktop
        const baseFont = window.innerWidth < 600 ? 12 : 16;
        waveCtx.font = `${baseFont * dpr}px system-ui`;
        waveCtx.fillStyle = '#777';

        // Optional shadow for readability
        waveCtx.shadowColor = 'rgba(0,0,0,0.3)';
        waveCtx.shadowBlur = 2;

        // Center text on canvas
        const metrics = waveCtx.measureText(msg);
        const x = (waveCanvas.width - metrics.width) / 2;
        const y = (waveCanvas.height / 2) + baseFont * dpr * 0.4;
        waveCtx.fillText(msg, x, y);

        generateBtn.disabled = true;
      } else {
        // Short files can be used directly
        recStatus.textContent = `Sample ready (${sampleBuffer.duration.toFixed(2)}s @ ${sampleBuffer.sampleRate}Hz)`;
        disableScratchArea(false);
        drawMainWave();
        generateBtn.disabled = false;
      }

      drawPreWave();
      updateLabels();
      recStatus.textContent = `Full original file reloaded (${sampleBuffer.duration.toFixed(2)}s).`;
    };


    // ==== main selection with play circle (no visible mid bar)
    let dragging = null; // 'start' | 'end' | 'move'
    const MAIN_HANDLE_EPS = 14 * (window.devicePixelRatio || 1);

    function isInsidePlayCircle(x, y) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);
      const midX = (a + b) / 2;
      const cy = waveCanvas.height / 2;

      const dpr = (window.devicePixelRatio || 1);
      const r = 14 * dpr;

      // echte afstand check
      const dx = x - midX;
      const dy = y - cy;
      return dx * dx + dy * dy <= r * r;
    }

    function mainHitTest(x) {
      const sX = secToX(clipStart, sampleBuffer?.duration, waveCanvas.width);
      const eX = secToX(clipEnd, sampleBuffer?.duration, waveCanvas.width);
      const a = Math.min(sX, eX), b = Math.max(sX, eX);

      if (Math.abs(x - sX) <= MAIN_HANDLE_EPS) return 'start';
      if (Math.abs(x - eX) <= MAIN_HANDLE_EPS) return 'end';
      if (x > a && x < b) return 'move';
      return 'new';
    }

    function updateMainCursor(e) {
      if (!sampleBuffer) {
        waveCanvas.style.cursor = 'not-allowed';
        return;
      }

      const x = canvasEventX(e, waveCanvas);
      const y = (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1);

      // Check playbutton eerst
      if (isInsidePlayCircle(x, y)) {
        waveCanvas.style.cursor = 'pointer';
        return;
      }

      const ht = mainHitTest(x);

      if (ht === 'move') {
        waveCanvas.style.cursor = 'grab';
      } else if (ht === 'start' || ht === 'end') {
        waveCanvas.style.cursor = 'ew-resize';
      } else if (ht === 'new') {
        waveCanvas.style.cursor = 'crosshair'; // vrij selecteren
      } else {
        waveCanvas.style.cursor = 'default';
      }
    }

    waveCanvas.addEventListener('pointerdown', (e) => {
      if (!sampleBuffer) return;
      waveCanvas.setPointerCapture(e.pointerId);
      const x = canvasEventX(e, waveCanvas);
      if (isInsidePlayCircle(x, (e.clientY - waveCanvas.getBoundingClientRect().top) * (window.devicePixelRatio || 1))) {
        if (playhead.active && playhead.where === 'main') {
          stopPlayhead();
        } else {
          playClipSelection();
        }
        return;
      }
      const ht = mainHitTest(x);
      if (ht === 'new') {
        const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
        clipStart = sec;
        clipEnd = sec;
      }
      dragging = ht;
    });
    waveCanvas.addEventListener('pointermove', (e) => {
      if (!dragging) updateMainCursor(e);
      if (!sampleBuffer || !dragging) return;
      const x = canvasEventX(e, waveCanvas);
      const sec = xToSec(x, sampleBuffer.duration, waveCanvas.width);
      if (dragging === 'start') clipStart = Math.min(sec, clipEnd - 0.005);
      else if (dragging === 'end') clipEnd = Math.max(sec, clipStart + 0.005);
      else if (dragging === 'move') { const width = clipEnd - clipStart; let ns = sec - width / 2; ns = clamp(ns, 0, (sampleBuffer.duration - width)); clipStart = ns; clipEnd = ns + width; }
      else if (dragging === 'new') {
        clipEnd = Math.max(sec, 0);
        clipStart = Math.min(sec, clipStart);
      }
      drawMainWave(); updateLabels();
    });
    waveCanvas.addEventListener('pointerup', (e) => { dragging = null; waveCanvas.releasePointerCapture(e.pointerId); updateMainCursor(e); });
    waveCanvas.addEventListener('pointerleave', () => { dragging = null; waveCanvas.style.cursor = 'crosshair'; });

    function playClipSelection() {
      if (!sampleBuffer) return;

      // stop eventueel vorige afspeler
      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      const src = audioCtx.createBufferSource();
      const chs = sampleBuffer.numberOfChannels;
      const sr = sampleBuffer.sampleRate;
      const len = Math.max(1, Math.floor((clipEnd - clipStart) * sr));
      const out = new AudioBuffer({ length: len, numberOfChannels: chs, sampleRate: sr });
      for (let ch = 0; ch < chs; ch++) {
        const inData = sampleBuffer.getChannelData(ch);
        const outData = out.getChannelData(ch);
        const startIdx = Math.floor(clipStart * sr);
        for (let i = 0; i < len; i++) {
          outData[i] = inData[startIdx + i] || 0;
        }
      }
      src.buffer = out;
      src.connect(audioCtx.destination);

      src.onended = () => {
        mainSrc = null;
        stopPlayhead();
      };

      src.start();
      mainSrc = src;

      startPlayhead('main', (clipEnd - clipStart));
    }

    function curveFromFormula(formula, samples, lo, hi) {
      let fn; try { fn = new Function('t', `return (${formula});`); } catch (err) { throw new Error('Formula error: ' + err.message); }
      const arr = new Float32Array(samples);
      for (let i = 0; i < samples; i++) { const t = samples > 1 ? i / (samples - 1) : 0; let v; try { v = fn(t); } catch (e) { v = 0; } if (!Number.isFinite(v)) v = 0; arr[i] = clamp(v, lo, hi); }
      return arr;
    }

    async function renderEffectToBuffer(preset) {
      if (!sampleBuffer) throw new Error('No sample loaded or recorded.');

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchFormula = preset.activeScratchFormula || preset.scratchFormula;
      const gainFormula = preset.activeGainFormula || preset.gainFormula;
      let scratchCurve = curveFromFormula(scratchFormula, scratchSamples, -1, 1);

      // Apply humanization if enabled
      if (humanizeScratchEl.checked) {
        scratchCurve = humanizeScratchCurve(scratchCurve);
      }
      const gainCurve = curveFromFormula(gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: bouw scratchInput buffer (sample + noise als één bron) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];

        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );

        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);

          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length]; // loop de noise
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = new AudioBuffer({
        length: scratchSamples,
        numberOfChannels: scratchInput.numberOfChannels,
        sampleRate: sr
      });

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }

        if (scratchSamples > 0) {
          const v = sampleCubic(inData, lastPos);
          outData[scratchSamples - 1] = v * gainCurve[scratchSamples - 1];
        }

        // Fade in/out (anti-click)
        const fadeSamples = Math.floor(sr * 0.05);
        for (let i = 0; i < fadeSamples; i++) {
          const t = i / fadeSamples;
          outData[i] *= t;
          const j = outData.length - 1 - i;
          if (j >= 0) outData[j] *= t;
        }
      }

      // === Stap 3: Slip Mode continuation ===
      if (slipModeEl.checked) {
        const sr = scratchInput.sampleRate;
        const scratchLen = out.length;
        const normalStart = Math.floor(clipStart * sr);
        const normalEnd = Math.floor(sampleBuffer.duration * sr);
        const normalLen = normalEnd - normalStart;

        const extended = new AudioBuffer({
          length: scratchLen + normalLen,
          numberOfChannels: out.numberOfChannels,
          sampleRate: sr
        });

        // Copy scratch part
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Append continuation (Slip Mode tail)
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);

          for (let i = 0; i < normalLen; i++) {
            const srcIdx = normalStart + i;
            const targetIdx = scratchLen + i;
            extData[targetIdx] = inData[srcIdx] || 0;
          }

          const fadeInSamples = Math.floor(sr * 0.01); // ≈10 ms
          for (let i = 0; i < fadeInSamples && i < normalLen; i++) {
            const t = i / fadeInSamples;
            const idx = scratchLen + i;
            extData[idx] *= t;
          }

          const fadeOutSamples = Math.floor(sr * 0.02); // ≈20 ms
          const endStart = extended.length - fadeOutSamples;
          for (let i = 0; i < fadeOutSamples && endStart + i < extended.length; i++) {
            const t = 1 - i / fadeOutSamples;
            extData[endStart + i] *= t;
          }
        }

        out = extended;
      }

      // === Stap 4: render in OfflineAudioContext ===
      return out;
    }

    // ==== Presets
    let presets = [];

    async function loadPresets() {
      try {
        const res = await fetch("scratches.json");
        presets = await res.json();

        // ✅ Zet standaard actieve formules
        presets.forEach(p => {
          p.activeScratchFormula = p.scratchFormula;
          p.activeGainFormula = p.gainFormula;
        });

        console.log("Scratch curves loaded:", presets);

        // Now initialize UI only after presets exist
        init();
      } catch (err) {
        console.error("Failed to load scratch curves:", err);
      }
    }

    function init() {
      fitCanvasToDisplay(preCanvas);
      fitCanvasToDisplay(waveCanvas);
      drawPreWave();
      drawMainWave();
      updateLabels();
      renderPresetGrid();
      recControls.classList.add('idle');
      setPreBtnState('play');
    }

    async function renderPresetGrid() {
      presetGrid.innerHTML = '';

      // --- één globale popup voor beats ---
      let options = document.querySelector('.beat-options');
      if (!options) {
        options = document.createElement('div');
        options.className = "beat-options";
        Object.assign(options.style, {
          position: "absolute",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
          padding: "6px 10px",
          background: "rgba(20,20,20,0.95)",
          border: "1px solid #333",
          borderRadius: "999px",
          boxShadow: "0 6px 20px rgba(0,0,0,0.5)",
          zIndex: "999999",
          opacity: "0",
          transform: "scale(0.8)",
          pointerEvents: "none",
          transition: "opacity 0.2s ease, transform 0.2s ease"
        });

        [1, 2, 3, 4].forEach(optBeat => {
          const opt = document.createElement('img');
          opt.src = `icons/beat-${optBeat}.svg`;
          opt.alt = `${optBeat} beat`;
          opt.style.width = "28px";
          opt.style.cursor = "pointer";
          options.appendChild(opt);
        });

        document.body.appendChild(options);
      }

      presets.forEach((p, idx) => {
        const node = presetCardTpl.content.cloneNode(true);
        const card = node.querySelector('.preset-card');
        const pnameEl = node.querySelector('.pname');
        pnameEl.textContent = p.name;

        // === OPTIE-PILL DROPDOWN ===
        const pill = node.querySelector('.option-pill');
        const optionsList = Object.keys(p)
          .filter(k => k.toLowerCase().startsWith('option'))
          .map(k => p[k])
          .filter(Boolean);

        if (optionsList.length > 1) {
          pill.classList.remove('hidden');
          const lastChoice = p.selectedOption;
          const defaultOption = lastChoice || p.defaultOption || optionsList[0];
          pill.textContent = defaultOption;

          const index = optionsList.indexOf(defaultOption);
          p.activeScratchFormula = p[`scratchFormula${index === 0 ? '' : index + 1}`];
          p.activeGainFormula = p[`gainFormula${index === 0 ? '' : index + 1}`];

          // maak dropdown
          const menu = document.createElement('div');
          menu.className = 'option-menu';
          optionsList.forEach(opt => {
            const btn = document.createElement('button');
            btn.textContent = opt;
            btn.addEventListener('click', async () => {
              pill.textContent = opt;
              p.selectedOption = opt;
              animatePresetReload(card);
              menu.classList.remove('show');

              // verwijder vorige selectie
              menu.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
              btn.classList.add('selected'); // ✅ highlight gekozen optie

              // stel juiste curves in
              const index = optionsList.indexOf(opt);
              p.activeScratchFormula = p[`scratchFormula${index === 0 ? '' : index + 1}`];
              p.activeGainFormula = p[`gainFormula${index === 0 ? '' : index + 1}`];

              // direct opnieuw renderen
              try {
                const rendered = await renderEffectToBuffer(p);
                presetBuffers[idx] = rendered;

                const durationEl = card.querySelector('.duration');
                if (rendered) durationEl.textContent = `${rendered.duration.toFixed(2)}s`;

                const mini = card.querySelector('.mini-wave');
                const beats = parseInt(p.duration, 10) || 1;
                drawMiniFromBuffer(mini, rendered, null, beats);

                globalStatus.textContent = `${p.name} (${opt}) updated`;
              } catch (err) {
                console.error("Re-render failed:", err);
                globalStatus.textContent = `⚠️ Render failed for ${p.name}`;
              }
            });
            menu.appendChild(btn);
          });
          document.body.appendChild(menu);

          // klikgedrag pill
          pill.addEventListener('click', (e) => {
            e.stopPropagation();
            const rect = pill.getBoundingClientRect();
            menu.style.top = `${rect.bottom + window.scrollY + 6}px`;
            menu.style.left = `${rect.left + window.scrollX}px`;

            const activeOpt = p.selectedOption || defaultOption;
            menu.querySelectorAll('button').forEach(b => {
              if (b.textContent.trim() === activeOpt) {
                b.classList.add('selected');
              } else {
                b.classList.remove('selected');
              }
            });

            if (!menu.classList.contains('show')) {
              menu.classList.add('show');
            } else {
              menu.classList.remove('show');
              menu.style.top = '-9999px';
              menu.style.left = '-9999px';
            }
          });

          // sluit menu bij klik buiten
          document.addEventListener('click', () => {
            menu.classList.remove('show');
            menu.style.top = '-9999px';
            menu.style.left = '-9999px';
          });
        } else {
          pill.classList.add('hidden');
          p.activeScratchFormula = p.scratchFormula;
          p.activeGainFormula = p.gainFormula;
        }

        // === BEAT SELECTOR ===
        const beats = parseInt(p.duration, 10) || 1;
        const currentBeat = presetBeats[idx] || beats;
        const beatIconWrap = node.querySelector('.beat-icon');

        beatIconWrap.innerHTML = `
      <img src="icons/beat-${currentBeat}.svg" alt="${currentBeat} beat" class="beat-svg">
    `;
        beatIconWrap.style.position = "relative";
        beatIconWrap.style.cursor = "pointer";

        let activeBeatIcon = null;

        beatIconWrap.addEventListener("click", (e) => {
          e.stopPropagation();

          // toggle popup
          if (activeBeatIcon === beatIconWrap) {
            options.style.opacity = "0";
            options.style.transform = "scale(0.8)";
            options.style.pointerEvents = "none";
            activeBeatIcon = null;
            return;
          }

          activeBeatIcon = beatIconWrap;
          const rect = beatIconWrap.getBoundingClientRect();
          options.style.top = (window.scrollY + rect.top - options.offsetHeight - 8) + "px";
          options.style.left = (window.scrollX + rect.left + rect.width / 2 - options.offsetWidth / 2) + "px";

          const currentBeat = presetBeats[idx] || parseInt(p.duration, 10) || 1;
          options.querySelectorAll('img').forEach(img => {
            const optBeat = parseInt(img.alt, 10);
            if (optBeat === currentBeat) {
              img.style.opacity = "1";
              img.style.transform = "scale(1.1)";
            } else {
              img.style.opacity = "0.2";
              img.style.transform = "scale(1)";
            }
          });

          options.style.opacity = "1";
          options.style.transform = "scale(1)";
          options.style.pointerEvents = "auto";

          // klik op beat icoon
          options.querySelectorAll('img').forEach(opt => {
            opt.onclick = async (ev) => {
              ev.stopPropagation();
              animatePresetReload(card);
              const optBeat = parseInt(opt.alt, 10);

              presets[idx].duration = optBeat;

              try {
                const rendered = await renderEffectToBuffer(presets[idx]);
                presetBuffers[idx] = rendered;
                presetBeats[idx] = optBeat;
              } catch (err) {
                console.error("Re-render failed:", err);
              }

              const durationEl = card.querySelector('.duration');
              if (presetBuffers[idx]) {
                durationEl.textContent = `${presetBuffers[idx].duration.toFixed(2)}s`;
              }
              const beatIconImg = card.querySelector('.beat-svg');
              beatIconImg.src = `icons/beat-${optBeat}.svg`;
              beatIconImg.alt = `${optBeat} beat`;

              const mini = card.querySelector('.mini-wave');
              if (presetBuffers[idx]) {
                drawMiniFromBuffer(mini, presetBuffers[idx], null, optBeat);
              }

              options.style.opacity = "0";
              options.style.transform = "scale(0.8)";
              options.style.pointerEvents = "none";
              activeBeatIcon = null;
            };
          });
        });

        // === duur + mini-wave ===
        if (presetBuffers[idx]) {
          node.querySelector('.duration').textContent = `${presetBuffers[idx].duration.toFixed(2)}s`;
        } else {
          const bpm = parseFloat(bpmEl.value || '120');
          const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
          node.querySelector('.duration').textContent = `${(beatDur * currentBeat).toFixed(2)}s`;
        }

        const mini = node.querySelector('.mini-wave');
        if (sampleBuffer) {
          const preview = synthesizePreviewBuffer(p);
          drawMiniFromBuffer(mini, preview, null, currentBeat);
        }

        // === knoppen ===
        const playBtn = node.querySelector('.playBtn');
        const dlBtn = node.querySelector('.dlBtn');
        playBtn.addEventListener('click', async () => {
          await handlePlayPreset(idx, playBtn, mini);
        });
        dlBtn.addEventListener('click', async () => {
          await handleDownloadPreset(idx);
        });
        mini.addEventListener('click', async () => {
          await handlePlayPreset(idx, playBtn, mini);
        });

        const reloadBtn = node.querySelector('.reload-btn');
        reloadBtn.addEventListener('click', async (e) => {
          animatePresetReload(card);
          e.stopPropagation();
          try {
            const rendered = await renderEffectToBuffer(p);
            presetBuffers[idx] = rendered;

            const durationEl = card.querySelector('.duration');
            durationEl.textContent = `${rendered.duration.toFixed(2)}s`;

            const mini = card.querySelector('.mini-wave');
            const beats = parseInt(p.duration, 10) || 1;
            drawMiniFromBuffer(mini, rendered, null, beats);

            globalStatus.textContent = `${p.name} reloaded.`;
          } catch (err) {
            console.error("Reload failed:", err);
            globalStatus.textContent = `⚠️ Reload failed for ${p.name}`;
          }
        });

        presetGrid.appendChild(node);
      });

      // sluit beat-popup bij klik buiten
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.beat-options') && !e.target.closest('.beat-icon')) {
          options.style.opacity = "0";
          options.style.transform = "scale(0.8)";
          options.style.pointerEvents = "none";
        }
      });
    }

// === Info popup (Scratch Area uitleg) ===
const infoIcon = document.getElementById('infoIcon');
const infoModal = document.getElementById('infoModal');
const infoClose = document.getElementById('infoClose');

if (infoIcon && infoModal && infoClose) {
  infoIcon.addEventListener('click', () => {
    infoModal.style.display = 'flex';
  });

  infoClose.addEventListener('click', () => {
    infoModal.style.display = 'none';
  });

  infoModal.addEventListener('click', (e) => {
    if (e.target === infoModal) {
      infoModal.style.display = 'none';
    }
  });
}

    function synthesizePreviewBuffer(preset) {
      if (!sampleBuffer) return null;

      const bpm = parseFloat(bpmEl.value || '120');
      const beatDur = 60 / (isFinite(bpm) ? bpm : 120);
      const beats = parseInt(preset.duration, 10) || 1;
      const scratchDur = beatDur * beats;

      const sr = sampleBuffer.sampleRate;
      const scratchSamples = Math.max(1, Math.floor(scratchDur * sr));
      const scratchFormula = preset.activeScratchFormula || preset.scratchFormula;
      const gainFormula = preset.activeGainFormula || preset.gainFormula;
      let scratchCurve = curveFromFormula(scratchFormula, scratchSamples, -1, 1);

      if (humanizeScratchEl.checked) {
        scratchCurve = humanizeScratchCurve(scratchCurve);
      }
      const gainCurve = curveFromFormula(gainFormula, scratchSamples, 0, 1);

      const sStart = Math.floor(clipStart * sr);
      const sEnd = Math.floor(clipEnd * sr);
      const sLen = Math.max(1, sEnd - sStart);

      // === Stap 1: scratchInput bouwen (sample + noise) ===
      let scratchInput = sampleBuffer;
      if (vinylNoiseEl.checked && noiseBuffers.length > 0) {
        const noise = noiseBuffers[Math.floor(Math.random() * noiseBuffers.length)];
        scratchInput = audioCtx.createBuffer(
          sampleBuffer.numberOfChannels,
          sampleBuffer.length,
          sampleBuffer.sampleRate
        );
        for (let ch = 0; ch < sampleBuffer.numberOfChannels; ch++) {
          const mainData = sampleBuffer.getChannelData(ch);
          const noiseData = noise.getChannelData(Math.min(ch, noise.numberOfChannels - 1));
          const scratchData = scratchInput.getChannelData(ch);
          for (let i = 0; i < sampleBuffer.length; i++) {
            const n = noiseData[i % noise.length];
            scratchData[i] = mainData[i] + (n * VINYL_NOISE_VOLUME);
          }
        }
      }

      // === Stap 2: scratch uitvoeren met scratchInput ===
      let out = audioCtx.createBuffer(
        scratchInput.numberOfChannels,
        scratchSamples,
        sr
      );

      let lastPos = sStart;

      for (let ch = 0; ch < out.numberOfChannels; ch++) {
        const inData = scratchInput.getChannelData(ch);
        const outData = out.getChannelData(ch);

        for (let i = 0; i < scratchSamples; i++) {
          const u = (scratchCurve[i] + 1) * 0.5;
          const srcPos = sStart + u * (sLen - 1);
          lastPos = srcPos;
          const v = sampleCubic(inData, srcPos);
          outData[i] = v * gainCurve[i];
        }
      }

      // === Stap 3: Slip Mode continuation (ook in preview!) ===
      // === Step 3: Slip Mode continuation (play scratch, then from start of scratch to end of preselection) ===
      if (slipModeEl.checked) {
        const sr = scratchInput.sampleRate;

        // Calculate lengths
        const scratchLen = out.length;
        const normalStart = Math.floor(clipStart * sr);
        const normalEnd = Math.floor(preEnd * sr);
        const normalLen = normalEnd - normalStart;

        // Make new buffer big enough for scratch + normal continuation
        const extended = new AudioBuffer({
          length: scratchLen + normalLen,
          numberOfChannels: out.numberOfChannels,
          sampleRate: sr
        });

        // Copy scratch effect
        for (let c = 0; c < out.numberOfChannels; c++) {
          extended.getChannelData(c).set(out.getChannelData(c), 0);
        }

        // Append clean playback from clipStart → preEnd
        for (let c = 0; c < out.numberOfChannels; c++) {
          const inData = scratchInput.getChannelData(c);
          const extData = extended.getChannelData(c);

          for (let i = 0; i < normalLen; i++) {
            const srcIdx = normalStart + i;
            extData[scratchLen + i] = inData[srcIdx] || 0;
          }
        }

        out = extended;
      }


      return out;
    }

    async function updatePresetThumbnails() {

      // Then loop over all preset cards and draw mini-wave previews
      const cards = presetGrid.querySelectorAll('.preset-card');
      cards.forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (!mini) return;
        const preview = synthesizePreviewBuffer(presets[idx]);
        if (preview) {
          drawMiniFromBuffer(mini, preview, null);
        }
      });
    }

    async function handlePlayPreset(i, buttonEl, miniCanvas) {
      try {
        await audioCtx.resume();

        // stop if already playing
        if (presetSrc) {
          presetSrc.stop();
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
          return;
        }

        // use cached buffer
        const rendered = presetBuffers[i];
        if (!rendered) {
          globalStatus.textContent = "Preset not generated yet. Click Generate first!";
          return;
        }

        const src = audioCtx.createBufferSource();
        src.buffer = rendered;
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(12000, audioCtx.currentTime); // cutoff ~12kHz
        src.connect(filter).connect(audioCtx.destination);

        src.onended = () => {
          presetSrc = null;
          stopPlayhead();
          buttonEl.textContent = 'Play';
          buttonEl.classList.remove('playing');
        };

        src.start();
        presetSrc = src;

        buttonEl.textContent = 'Stop';
        buttonEl.classList.add('playing');
        startPlayhead('mini', rendered.duration, miniCanvas, i);
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    // MAIN DOWNLOAD FUNCTION
    async function handleDownloadPreset(i) {
      try {
        // TODO: Auth
        // Check if user is authenticated
        if (!AppState.isAuthenticated) {
          showAuthModal('login');
          return;
        }

        // Check download eligibility
        const eligibility = await checkDownloadEligibility();
        if (!eligibility.allowed) {
          showUpgradeModal();
          // TODO: Auth
          return;
        }

        const rendered = await renderEffectToBuffer(presets[i]);
        const wav = audioBufferToWav(rendered);
        const url = URL.createObjectURL(wav);
        const a = document.createElement('a');
        a.href = url;

        const bpm = parseFloat(bpmEl.value || '120');
        const bpmStr = isFinite(bpm) ? `${Math.round(bpm)}bpm` : 'bpm';
        const presetName = presets[i].name?.replace(/[^a-z0-9_-]+/ig, '_') || 'Preset';
        const optionName = presets[i].selectedOption
          ? presets[i].selectedOption.replace(/[^a-z0-9_-]+/ig, '_')
          : '';

        let fileName = presetName;
        if (optionName) fileName += `_${optionName}`;
        fileName += `_${bpmStr}.wav`;

        a.download = fileName;
        a.click();

        // Track download after successful file generation
        await trackDownload(fileName);

        globalStatus.textContent = `${presets[i].name}${optionName ? ` (${optionName})` : ''} downloaded at ${bpmStr}`;
      } catch (err) {
        globalStatus.textContent = err.message;
      }
    }

    function audioBufferToWav(buffer) { const numCh = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const length = buffer.length; const bps = 2; const blockAlign = numCh * bps; const byteRate = sampleRate * blockAlign; const dataSize = length * blockAlign; const total = 44 + dataSize; const ab = new ArrayBuffer(total); const dv = new DataView(ab); let p = 0; function w8(v) { dv.setUint8(p++, v); } function w16(v) { dv.setUint16(p, v, true); p += 2; } function w32(v) { dv.setUint32(p, v, true); p += 4; } w8(0x52); w8(0x49); w8(0x46); w8(0x46); w32(36 + dataSize); w8(0x57); w8(0x41); w8(0x56); w8(0x45); w8(0x66); w8(0x6d); w8(0x74); w8(0x20); w32(16); w16(1); w16(numCh); w32(sampleRate); w32(byteRate); w16(blockAlign); w16(16); w8(0x64); w8(0x61); w8(0x74); w8(0x61); w32(dataSize); const chans = []; for (let ch = 0; ch < numCh; ch++) chans.push(buffer.getChannelData(ch)); for (let i = 0; i < length; i++) { for (let ch = 0; ch < numCh; ch++) { let s = Math.max(-1, Math.min(1, chans[ch][i])); s = s < 0 ? s * 0x8000 : s * 0x7fff; dv.setInt16(p, s, true); p += 2; } } return new Blob([ab], { type: 'audio/wav' }); }

    function startPlayhead(where, duration, canvas = null, miniIdx = -1, onEnd = null) {
      playhead.active = true; playhead.startAt = audioCtx.currentTime; playhead.duration = duration; playhead.where = where; playhead.canvas = canvas; playhead.miniIdx = miniIdx; if (rafId) cancelAnimationFrame(rafId);
      const tick = () => {
        const t = audioCtx.currentTime - playhead.startAt; if (t >= duration) { stopPlayhead(); onEnd && onEnd(); return; } if (where === 'main') drawMainWave(); else if (where === 'pre') drawPreWave(); else if (where === 'mini' && canvas) {
          const buf = presetBuffers[miniIdx];
          if (buf) {
            const beats = parseInt(presets[miniIdx].duration, 10) || 1;
            drawMiniFromBuffer(canvas, buf, t / duration, beats);
          }
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function stopPlayhead() {
      playhead.active = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      if (mainSrc) {
        mainSrc.stop();
        mainSrc = null;
      }

      if (presetSrc) {
        presetSrc.stop();
        presetSrc = null;
      }

      if (playhead.where === 'main') drawMainWave();
      if (playhead.where === 'pre') drawPreWave();
      if (playhead.where === 'mini' && playhead.canvas) {
        const buf = presetBuffers[playhead.miniIdx];
        const beats = presetBeats[playhead.miniIdx] || 1;
        if (buf) drawMiniFromBuffer(playhead.canvas, buf, null, beats);
      }
      playhead.where = 'none';
    }

    function init() { fitCanvasToDisplay(preCanvas); fitCanvasToDisplay(waveCanvas); drawPreWave(); drawMainWave(); updateLabels(); renderPresetGrid(); recControls.classList.add('idle'); setPreBtnState('play'); }
    init();

    generateBtn.addEventListener('click', async () => {
      if (!sampleBuffer) {
        recStatus.textContent = "No sample loaded.";
        return;
      }
      if ((clipEnd - clipStart) <= 0) {
        recStatus.textContent = "No audio selected for scratching.";
        return;
      }

      lastGeneratedWithSlip = slipModeEl.checked;
      presetBuffers = [];

      // eerst echt renderen (met noise/slip/random)
      for (let i = 0; i < presets.length; i++) {
        try {
          const rendered = await renderEffectToBuffer(presets[i]);
          presetBuffers[i] = rendered;
          presetBeats[i] = parseInt(presets[i].duration, 10) || 1;
        } catch (err) {
          presetBuffers[i] = null;
          console.error("Preset render failed:", err);
        }
      }

      // pas hier UI tekenen met exacte buffers
      renderPresetGrid();

      // previews tekenen op basis van de echte buffers
      presetGrid.querySelectorAll('.preset-card').forEach((card, idx) => {
        const mini = card.querySelector('.mini-wave');
        if (presetBuffers[idx]) {
          const beats = presetBeats[idx] || 1;
          drawMiniFromBuffer(mini, presetBuffers[idx], null, beats);
        }
      });

      // enable animaties
      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-card').forEach((card, idx) => {
          setTimeout(() => {
            card.classList.add('enabled');
            const actions = card.querySelector('.preset-actions');
            if (actions) actions.classList.add('enabled');
          }, idx * 100);
        });
      });

      requestAnimationFrame(() => {
        document.querySelectorAll('.preset-card').forEach((el, idx) => {
          setTimeout(() => el.classList.add('enabled'), idx * 100);
        });
      });
    });


    const bubbleContainer = document.getElementById("bubbleContainer");

    function createBubble() {
      const bubble = document.createElement("span");
      bubble.classList.add("bubble");

      // Willekeurige grootte tussen 15 en 100 px
      const size = Math.floor(Math.random() * 60) + 15;
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;

      // Willekeurige horizontale positie
      const left = Math.random() * 100;
      bubble.style.left = `${left}%`;

      // Willekeurige duur van animatie (tussen 8 en 15 sec)
      const duration = Math.random() * 7 + 8;
      bubble.style.animationDuration = `${duration}s`;

      // Voeg toe aan DOM
      bubbleContainer.appendChild(bubble);

      // Verwijder bubble uit DOM na animatie om geheugen te sparen
      setTimeout(() => {
        bubble.remove();
      }, duration * 1000);
    }

    function animatePresetReload(card) {
      if (!card) return;
      // temporarily disable & fade out
      card.classList.remove('enabled');
      const actions = card.querySelector('.preset-actions');
      if (actions) actions.classList.remove('enabled');
      card.style.pointerEvents = 'none';

      // fade-out animation (already in CSS transition)
      setTimeout(() => {
        // re-enable visually after delay
        card.classList.add('enabled');
        if (actions) actions.classList.add('enabled');
        card.style.pointerEvents = 'auto';
      }, 150); // matches the .6s CSS transition duration
    }


    function updateTouchAction() {
      const preCanvas = document.getElementById('preCanvas');
      const waveCanvas = document.getElementById('waveCanvas');

      if (sampleBuffer) {
        preCanvas.style.touchAction = 'none';
        waveCanvas.style.touchAction = 'none';
      } else {
        preCanvas.style.touchAction = 'auto';
        waveCanvas.style.touchAction = 'auto';
      }
    }

    function humanizeScratchCurve(curve) {
      const len = curve.length;
      if (len < 2) return curve;

      const warped = new Float32Array(len);

      // === PARAMETERS ===
      const ampDepth = 0.02 + Math.random() * 0.015;   // amplitude variation
      const ampFreq = 1 + Math.random();               // amplitude speed
      const ampPhase = Math.random() * Math.PI * 2;

      const timeWarpDepth = 0.015;                     // timing variation
      const timeWarpFreq = 0.3 + Math.random() * 0.6;   // slower, 0.3–0.9 Hz
      const timeWarpPhase = Math.random() * Math.PI * 2;

      // Precompute warped time base
      const warpedT = new Float32Array(len);
      for (let i = 0; i < len; i++) {
        const t = i / (len - 1);
        warpedT[i] = t + timeWarpDepth * Math.sin(2 * Math.PI * timeWarpFreq * t + timeWarpPhase);
      }

      // Normalize time base (so it still starts at 0 and ends at 1)
      const minT = warpedT[0];
      const maxT = warpedT[len - 1];
      for (let i = 0; i < len; i++) {
        warpedT[i] = (warpedT[i] - minT) / (maxT - minT);
      }

      // Resample original curve onto warped time base
      for (let i = 0; i < len; i++) {
        const t = warpedT[i];
        const idx = t * (len - 1);
        const i0 = Math.floor(idx);
        const i1 = Math.min(len - 1, i0 + 1);
        const frac = idx - i0;
        const base = curve[i0] + (curve[i1] - curve[i0]) * frac;

        // Apply gentle amplitude modulation
        const ampFactor = 1 + ampDepth * Math.sin(2 * Math.PI * ampFreq * t + ampPhase);
        warped[i] = base * ampFactor;
      }

      // Ensure first and last values are preserved exactly
      warped[0] = curve[0];
      warped[len - 1] = curve[len - 1];

      return warped;
    }


    // Elke 2 seconden een bubble maken
    setInterval(createBubble, 2000);

    document.addEventListener('click', () => {
      document.querySelectorAll('.beat-popup').forEach(p => p.style.display = 'none');
    });

    loadNoiseBuffers();
    loadPresets();
  </script>
</body>

</html>